{"ast":null,"code":"import _slicedToArray from\"/Users/EthanTran/Desktop/Squid-Note/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";/**\n * React Router v6.2.1\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */import{createContext,useRef,useState,useLayoutEffect,createElement,useContext,useEffect,useMemo,useCallback,Children,isValidElement,Fragment}from'react';import{createMemoryHistory,Action,parsePath}from'history';function invariant(cond,message){if(!cond)throw new Error(message);}function warning(cond,message){if(!cond){// eslint-disable-next-line no-console\nif(typeof console!==\"undefined\")console.warn(message);try{// Welcome to debugging React Router!\n//\n// This error is thrown as a convenience so you can more easily\n// find the source for a warning that appears in the console by\n// enabling \"pause on exceptions\" in your JavaScript debugger.\nthrow new Error(message);// eslint-disable-next-line no-empty\n}catch(e){}}}var alreadyWarned={};function warningOnce(key,cond,message){if(!cond&&!alreadyWarned[key]){alreadyWarned[key]=true;process.env.NODE_ENV!==\"production\"?warning(false,message):void 0;}}///////////////////////////////////////////////////////////////////////////////\n// CONTEXT\n///////////////////////////////////////////////////////////////////////////////\n/**\n * A Navigator is a \"location changer\"; it's how you get to different locations.\n *\n * Every history instance conforms to the Navigator interface, but the\n * distinction is useful primarily when it comes to the low-level <Router> API\n * where both the location and a navigator must be provided separately in order\n * to avoid \"tearing\" that may occur in a suspense-enabled app if the action\n * and/or location were to be read directly from the history instance.\n */var NavigationContext=/*#__PURE__*/createContext(null);if(process.env.NODE_ENV!==\"production\"){NavigationContext.displayName=\"Navigation\";}var LocationContext=/*#__PURE__*/createContext(null);if(process.env.NODE_ENV!==\"production\"){LocationContext.displayName=\"Location\";}var RouteContext=/*#__PURE__*/createContext({outlet:null,matches:[]});if(process.env.NODE_ENV!==\"production\"){RouteContext.displayName=\"Route\";}///////////////////////////////////////////////////////////////////////////////\n// COMPONENTS\n///////////////////////////////////////////////////////////////////////////////\n/**\n * A <Router> that stores all entries in memory.\n *\n * @see https://reactrouter.com/docs/en/v6/api#memoryrouter\n */function MemoryRouter(_ref){var basename=_ref.basename,children=_ref.children,initialEntries=_ref.initialEntries,initialIndex=_ref.initialIndex;var historyRef=useRef();if(historyRef.current==null){historyRef.current=createMemoryHistory({initialEntries:initialEntries,initialIndex:initialIndex});}var history=historyRef.current;var _useState=useState({action:history.action,location:history.location}),_useState2=_slicedToArray(_useState,2),state=_useState2[0],setState=_useState2[1];useLayoutEffect(function(){return history.listen(setState);},[history]);return/*#__PURE__*/createElement(Router,{basename:basename,children:children,location:state.location,navigationType:state.action,navigator:history});}/**\n * Changes the current location.\n *\n * Note: This API is mostly useful in React.Component subclasses that are not\n * able to use hooks. In functional components, we recommend you use the\n * `useNavigate` hook instead.\n *\n * @see https://reactrouter.com/docs/en/v6/api#navigate\n */function Navigate(_ref2){var to=_ref2.to,replace=_ref2.replace,state=_ref2.state;!useInRouterContext()?process.env.NODE_ENV!==\"production\"?invariant(false,// TODO: This error is probably because they somehow have 2 versions of\n// the router loaded. We can help them understand how to avoid that.\n\"<Navigate> may be used only in the context of a <Router> component.\"):invariant(false):void 0;process.env.NODE_ENV!==\"production\"?warning(!useContext(NavigationContext).static,\"<Navigate> must not be used on the initial render in a <StaticRouter>. \"+\"This is a no-op, but you should modify your code so the <Navigate> is \"+\"only ever rendered in response to some user interaction or state change.\"):void 0;var navigate=useNavigate();useEffect(function(){navigate(to,{replace:replace,state:state});});return null;}/**\n * Renders the child route's element, if there is one.\n *\n * @see https://reactrouter.com/docs/en/v6/api#outlet\n */function Outlet(props){return useOutlet(props.context);}/**\n * Declares an element that should be rendered at a certain URL path.\n *\n * @see https://reactrouter.com/docs/en/v6/api#route\n */function Route(_props){process.env.NODE_ENV!==\"production\"?invariant(false,\"A <Route> is only ever to be used as the child of <Routes> element, \"+\"never rendered directly. Please wrap your <Route> in a <Routes>.\"):invariant(false);}/**\n * Provides location context for the rest of the app.\n *\n * Note: You usually won't render a <Router> directly. Instead, you'll render a\n * router that is more specific to your environment such as a <BrowserRouter>\n * in web browsers or a <StaticRouter> for server rendering.\n *\n * @see https://reactrouter.com/docs/en/v6/api#router\n */function Router(_ref3){var _ref3$basename=_ref3.basename,basenameProp=_ref3$basename===void 0?\"/\":_ref3$basename,_ref3$children=_ref3.children,children=_ref3$children===void 0?null:_ref3$children,locationProp=_ref3.location,_ref3$navigationType=_ref3.navigationType,navigationType=_ref3$navigationType===void 0?Action.Pop:_ref3$navigationType,navigator=_ref3.navigator,_ref3$static=_ref3.static,staticProp=_ref3$static===void 0?false:_ref3$static;!!useInRouterContext()?process.env.NODE_ENV!==\"production\"?invariant(false,\"You cannot render a <Router> inside another <Router>.\"+\" You should never have more than one in your app.\"):invariant(false):void 0;var basename=normalizePathname(basenameProp);var navigationContext=useMemo(function(){return{basename:basename,navigator:navigator,static:staticProp};},[basename,navigator,staticProp]);if(typeof locationProp===\"string\"){locationProp=parsePath(locationProp);}var _locationProp=locationProp,_locationProp$pathnam=_locationProp.pathname,pathname=_locationProp$pathnam===void 0?\"/\":_locationProp$pathnam,_locationProp$search=_locationProp.search,search=_locationProp$search===void 0?\"\":_locationProp$search,_locationProp$hash=_locationProp.hash,hash=_locationProp$hash===void 0?\"\":_locationProp$hash,_locationProp$state=_locationProp.state,state=_locationProp$state===void 0?null:_locationProp$state,_locationProp$key=_locationProp.key,key=_locationProp$key===void 0?\"default\":_locationProp$key;var location=useMemo(function(){var trailingPathname=stripBasename(pathname,basename);if(trailingPathname==null){return null;}return{pathname:trailingPathname,search:search,hash:hash,state:state,key:key};},[basename,pathname,search,hash,state,key]);process.env.NODE_ENV!==\"production\"?warning(location!=null,\"<Router basename=\\\"\"+basename+\"\\\"> is not able to match the URL \"+(\"\\\"\"+pathname+search+hash+\"\\\" because it does not start with the \")+\"basename, so the <Router> won't render anything.\"):void 0;if(location==null){return null;}return/*#__PURE__*/createElement(NavigationContext.Provider,{value:navigationContext},/*#__PURE__*/createElement(LocationContext.Provider,{children:children,value:{location:location,navigationType:navigationType}}));}/**\n * A container for a nested tree of <Route> elements that renders the branch\n * that best matches the current location.\n *\n * @see https://reactrouter.com/docs/en/v6/api#routes\n */function Routes(_ref4){var children=_ref4.children,location=_ref4.location;return useRoutes(createRoutesFromChildren(children),location);}///////////////////////////////////////////////////////////////////////////////\n// HOOKS\n///////////////////////////////////////////////////////////////////////////////\n/**\n * Returns the full href for the given \"to\" value. This is useful for building\n * custom links that are also accessible and preserve right-click behavior.\n *\n * @see https://reactrouter.com/docs/en/v6/api#usehref\n */function useHref(to){!useInRouterContext()?process.env.NODE_ENV!==\"production\"?invariant(false,// TODO: This error is probably because they somehow have 2 versions of the\n// router loaded. We can help them understand how to avoid that.\n\"useHref() may be used only in the context of a <Router> component.\"):invariant(false):void 0;var _useContext=useContext(NavigationContext),basename=_useContext.basename,navigator=_useContext.navigator;var _useResolvedPath=useResolvedPath(to),hash=_useResolvedPath.hash,pathname=_useResolvedPath.pathname,search=_useResolvedPath.search;var joinedPathname=pathname;if(basename!==\"/\"){var toPathname=getToPathname(to);var endsWithSlash=toPathname!=null&&toPathname.endsWith(\"/\");joinedPathname=pathname===\"/\"?basename+(endsWithSlash?\"/\":\"\"):joinPaths([basename,pathname]);}return navigator.createHref({pathname:joinedPathname,search:search,hash:hash});}/**\n * Returns true if this component is a descendant of a <Router>.\n *\n * @see https://reactrouter.com/docs/en/v6/api#useinroutercontext\n */function useInRouterContext(){return useContext(LocationContext)!=null;}/**\n * Returns the current location object, which represents the current URL in web\n * browsers.\n *\n * Note: If you're using this it may mean you're doing some of your own\n * \"routing\" in your app, and we'd like to know what your use case is. We may\n * be able to provide something higher-level to better suit your needs.\n *\n * @see https://reactrouter.com/docs/en/v6/api#uselocation\n */function useLocation(){!useInRouterContext()?process.env.NODE_ENV!==\"production\"?invariant(false,// TODO: This error is probably because they somehow have 2 versions of the\n// router loaded. We can help them understand how to avoid that.\n\"useLocation() may be used only in the context of a <Router> component.\"):invariant(false):void 0;return useContext(LocationContext).location;}/**\n * Returns the current navigation action which describes how the router came to\n * the current location, either by a pop, push, or replace on the history stack.\n *\n * @see https://reactrouter.com/docs/en/v6/api#usenavigationtype\n */function useNavigationType(){return useContext(LocationContext).navigationType;}/**\n * Returns true if the URL for the given \"to\" value matches the current URL.\n * This is useful for components that need to know \"active\" state, e.g.\n * <NavLink>.\n *\n * @see https://reactrouter.com/docs/en/v6/api#usematch\n */function useMatch(pattern){!useInRouterContext()?process.env.NODE_ENV!==\"production\"?invariant(false,// TODO: This error is probably because they somehow have 2 versions of the\n// router loaded. We can help them understand how to avoid that.\n\"useMatch() may be used only in the context of a <Router> component.\"):invariant(false):void 0;var _useLocation=useLocation(),pathname=_useLocation.pathname;return useMemo(function(){return matchPath(pattern,pathname);},[pathname,pattern]);}/**\n * The interface for the navigate() function returned from useNavigate().\n */ /**\n * Returns an imperative method for changing the location. Used by <Link>s, but\n * may also be used by other elements to change the location.\n *\n * @see https://reactrouter.com/docs/en/v6/api#usenavigate\n */function useNavigate(){!useInRouterContext()?process.env.NODE_ENV!==\"production\"?invariant(false,// TODO: This error is probably because they somehow have 2 versions of the\n// router loaded. We can help them understand how to avoid that.\n\"useNavigate() may be used only in the context of a <Router> component.\"):invariant(false):void 0;var _useContext2=useContext(NavigationContext),basename=_useContext2.basename,navigator=_useContext2.navigator;var _useContext3=useContext(RouteContext),matches=_useContext3.matches;var _useLocation2=useLocation(),locationPathname=_useLocation2.pathname;var routePathnamesJson=JSON.stringify(matches.map(function(match){return match.pathnameBase;}));var activeRef=useRef(false);useEffect(function(){activeRef.current=true;});var navigate=useCallback(function(to,options){if(options===void 0){options={};}process.env.NODE_ENV!==\"production\"?warning(activeRef.current,\"You should call navigate() in a React.useEffect(), not when \"+\"your component is first rendered.\"):void 0;if(!activeRef.current)return;if(typeof to===\"number\"){navigator.go(to);return;}var path=resolveTo(to,JSON.parse(routePathnamesJson),locationPathname);if(basename!==\"/\"){path.pathname=joinPaths([basename,path.pathname]);}(!!options.replace?navigator.replace:navigator.push)(path,options.state);},[basename,navigator,routePathnamesJson,locationPathname]);return navigate;}var OutletContext=/*#__PURE__*/createContext(null);/**\n * Returns the context (if provided) for the child route at this level of the route\n * hierarchy.\n * @see https://reactrouter.com/docs/en/v6/api#useoutletcontext\n */function useOutletContext(){return useContext(OutletContext);}/**\n * Returns the element for the child route at this level of the route\n * hierarchy. Used internally by <Outlet> to render child routes.\n *\n * @see https://reactrouter.com/docs/en/v6/api#useoutlet\n */function useOutlet(context){var outlet=useContext(RouteContext).outlet;if(outlet){return/*#__PURE__*/createElement(OutletContext.Provider,{value:context},outlet);}return outlet;}/**\n * Returns an object of key/value pairs of the dynamic params from the current\n * URL that were matched by the route path.\n *\n * @see https://reactrouter.com/docs/en/v6/api#useparams\n */function useParams(){var _useContext4=useContext(RouteContext),matches=_useContext4.matches;var routeMatch=matches[matches.length-1];return routeMatch?routeMatch.params:{};}/**\n * Resolves the pathname of the given `to` value against the current location.\n *\n * @see https://reactrouter.com/docs/en/v6/api#useresolvedpath\n */function useResolvedPath(to){var _useContext5=useContext(RouteContext),matches=_useContext5.matches;var _useLocation3=useLocation(),locationPathname=_useLocation3.pathname;var routePathnamesJson=JSON.stringify(matches.map(function(match){return match.pathnameBase;}));return useMemo(function(){return resolveTo(to,JSON.parse(routePathnamesJson),locationPathname);},[to,routePathnamesJson,locationPathname]);}/**\n * Returns the element of the route that matched the current location, prepared\n * with the correct context to render the remainder of the route tree. Route\n * elements in the tree must render an <Outlet> to render their child route's\n * element.\n *\n * @see https://reactrouter.com/docs/en/v6/api#useroutes\n */function useRoutes(routes,locationArg){!useInRouterContext()?process.env.NODE_ENV!==\"production\"?invariant(false,// TODO: This error is probably because they somehow have 2 versions of the\n// router loaded. We can help them understand how to avoid that.\n\"useRoutes() may be used only in the context of a <Router> component.\"):invariant(false):void 0;var _useContext6=useContext(RouteContext),parentMatches=_useContext6.matches;var routeMatch=parentMatches[parentMatches.length-1];var parentParams=routeMatch?routeMatch.params:{};var parentPathname=routeMatch?routeMatch.pathname:\"/\";var parentPathnameBase=routeMatch?routeMatch.pathnameBase:\"/\";var parentRoute=routeMatch&&routeMatch.route;if(process.env.NODE_ENV!==\"production\"){// You won't get a warning about 2 different <Routes> under a <Route>\n// without a trailing *, but this is a best-effort warning anyway since we\n// cannot even give the warning unless they land at the parent route.\n//\n// Example:\n//\n// <Routes>\n//   {/* This route path MUST end with /* because otherwise\n//       it will never match /blog/post/123 */}\n//   <Route path=\"blog\" element={<Blog />} />\n//   <Route path=\"blog/feed\" element={<BlogFeed />} />\n// </Routes>\n//\n// function Blog() {\n//   return (\n//     <Routes>\n//       <Route path=\"post/:id\" element={<Post />} />\n//     </Routes>\n//   );\n// }\nvar parentPath=parentRoute&&parentRoute.path||\"\";warningOnce(parentPathname,!parentRoute||parentPath.endsWith(\"*\"),\"You rendered descendant <Routes> (or called `useRoutes()`) at \"+(\"\\\"\"+parentPathname+\"\\\" (under <Route path=\\\"\"+parentPath+\"\\\">) but the \")+\"parent route path has no trailing \\\"*\\\". This means if you navigate \"+\"deeper, the parent won't match anymore and therefore the child \"+\"routes will never render.\\n\\n\"+(\"Please change the parent <Route path=\\\"\"+parentPath+\"\\\"> to <Route \")+(\"path=\\\"\"+(parentPath===\"/\"?\"*\":parentPath+\"/*\")+\"\\\">.\"));}var locationFromContext=useLocation();var location;if(locationArg){var _parsedLocationArg$pa;var parsedLocationArg=typeof locationArg===\"string\"?parsePath(locationArg):locationArg;!(parentPathnameBase===\"/\"||((_parsedLocationArg$pa=parsedLocationArg.pathname)==null?void 0:_parsedLocationArg$pa.startsWith(parentPathnameBase)))?process.env.NODE_ENV!==\"production\"?invariant(false,\"When overriding the location using `<Routes location>` or `useRoutes(routes, location)`, \"+\"the location pathname must begin with the portion of the URL pathname that was \"+(\"matched by all parent routes. The current pathname base is \\\"\"+parentPathnameBase+\"\\\" \")+(\"but pathname \\\"\"+parsedLocationArg.pathname+\"\\\" was given in the `location` prop.\")):invariant(false):void 0;location=parsedLocationArg;}else{location=locationFromContext;}var pathname=location.pathname||\"/\";var remainingPathname=parentPathnameBase===\"/\"?pathname:pathname.slice(parentPathnameBase.length)||\"/\";var matches=matchRoutes(routes,{pathname:remainingPathname});if(process.env.NODE_ENV!==\"production\"){process.env.NODE_ENV!==\"production\"?warning(parentRoute||matches!=null,\"No routes matched location \\\"\"+location.pathname+location.search+location.hash+\"\\\" \"):void 0;process.env.NODE_ENV!==\"production\"?warning(matches==null||matches[matches.length-1].route.element!==undefined,\"Matched leaf route at location \\\"\"+location.pathname+location.search+location.hash+\"\\\" does not have an element. \"+\"This means it will render an <Outlet /> with a null value by default resulting in an \\\"empty\\\" page.\"):void 0;}return _renderMatches(matches&&matches.map(function(match){return Object.assign({},match,{params:Object.assign({},parentParams,match.params),pathname:joinPaths([parentPathnameBase,match.pathname]),pathnameBase:match.pathnameBase===\"/\"?parentPathnameBase:joinPaths([parentPathnameBase,match.pathnameBase])});}),parentMatches);}///////////////////////////////////////////////////////////////////////////////\n// UTILS\n///////////////////////////////////////////////////////////////////////////////\n/**\n * Creates a route config from a React \"children\" object, which is usually\n * either a `<Route>` element or an array of them. Used internally by\n * `<Routes>` to create a route config from its children.\n *\n * @see https://reactrouter.com/docs/en/v6/api#createroutesfromchildren\n */function createRoutesFromChildren(children){var routes=[];Children.forEach(children,function(element){if(!/*#__PURE__*/isValidElement(element)){// Ignore non-elements. This allows people to more easily inline\n// conditionals in their route config.\nreturn;}if(element.type===Fragment){// Transparently support React.Fragment and its children.\nroutes.push.apply(routes,createRoutesFromChildren(element.props.children));return;}!(element.type===Route)?process.env.NODE_ENV!==\"production\"?invariant(false,\"[\"+(typeof element.type===\"string\"?element.type:element.type.name)+\"] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>\"):invariant(false):void 0;var route={caseSensitive:element.props.caseSensitive,element:element.props.element,index:element.props.index,path:element.props.path};if(element.props.children){route.children=createRoutesFromChildren(element.props.children);}routes.push(route);});return routes;}/**\n * The parameters that were parsed from the URL path.\n */ /**\n * Returns a path with params interpolated.\n *\n * @see https://reactrouter.com/docs/en/v6/api#generatepath\n */function generatePath(path,params){if(params===void 0){params={};}return path.replace(/:(\\w+)/g,function(_,key){!(params[key]!=null)?process.env.NODE_ENV!==\"production\"?invariant(false,\"Missing \\\":\"+key+\"\\\" param\"):invariant(false):void 0;return params[key];}).replace(/\\/*\\*$/,function(_){return params[\"*\"]==null?\"\":params[\"*\"].replace(/^\\/*/,\"/\");});}/**\n * A RouteMatch contains info about how a route matched a URL.\n */ /**\n * Matches the given routes to a location and returns the match data.\n *\n * @see https://reactrouter.com/docs/en/v6/api#matchroutes\n */function matchRoutes(routes,locationArg,basename){if(basename===void 0){basename=\"/\";}var location=typeof locationArg===\"string\"?parsePath(locationArg):locationArg;var pathname=stripBasename(location.pathname||\"/\",basename);if(pathname==null){return null;}var branches=flattenRoutes(routes);rankRouteBranches(branches);var matches=null;for(var i=0;matches==null&&i<branches.length;++i){matches=matchRouteBranch(branches[i],pathname);}return matches;}function flattenRoutes(routes,branches,parentsMeta,parentPath){if(branches===void 0){branches=[];}if(parentsMeta===void 0){parentsMeta=[];}if(parentPath===void 0){parentPath=\"\";}routes.forEach(function(route,index){var meta={relativePath:route.path||\"\",caseSensitive:route.caseSensitive===true,childrenIndex:index,route:route};if(meta.relativePath.startsWith(\"/\")){!meta.relativePath.startsWith(parentPath)?process.env.NODE_ENV!==\"production\"?invariant(false,\"Absolute route path \\\"\"+meta.relativePath+\"\\\" nested under path \"+(\"\\\"\"+parentPath+\"\\\" is not valid. An absolute child route path \")+\"must start with the combined path of all its parent routes.\"):invariant(false):void 0;meta.relativePath=meta.relativePath.slice(parentPath.length);}var path=joinPaths([parentPath,meta.relativePath]);var routesMeta=parentsMeta.concat(meta);// Add the children before adding this route to the array so we traverse the\n// route tree depth-first and child routes appear before their parents in\n// the \"flattened\" version.\nif(route.children&&route.children.length>0){!(route.index!==true)?process.env.NODE_ENV!==\"production\"?invariant(false,\"Index routes must not have child routes. Please remove \"+(\"all child routes from route path \\\"\"+path+\"\\\".\")):invariant(false):void 0;flattenRoutes(route.children,branches,routesMeta,path);}// Routes without a path shouldn't ever match by themselves unless they are\n// index routes, so don't add them to the list of possible branches.\nif(route.path==null&&!route.index){return;}branches.push({path:path,score:computeScore(path,route.index),routesMeta:routesMeta});});return branches;}function rankRouteBranches(branches){branches.sort(function(a,b){return a.score!==b.score?b.score-a.score// Higher score first\n:compareIndexes(a.routesMeta.map(function(meta){return meta.childrenIndex;}),b.routesMeta.map(function(meta){return meta.childrenIndex;}));});}var paramRe=/^:\\w+$/;var dynamicSegmentValue=3;var indexRouteValue=2;var emptySegmentValue=1;var staticSegmentValue=10;var splatPenalty=-2;var isSplat=function isSplat(s){return s===\"*\";};function computeScore(path,index){var segments=path.split(\"/\");var initialScore=segments.length;if(segments.some(isSplat)){initialScore+=splatPenalty;}if(index){initialScore+=indexRouteValue;}return segments.filter(function(s){return!isSplat(s);}).reduce(function(score,segment){return score+(paramRe.test(segment)?dynamicSegmentValue:segment===\"\"?emptySegmentValue:staticSegmentValue);},initialScore);}function compareIndexes(a,b){var siblings=a.length===b.length&&a.slice(0,-1).every(function(n,i){return n===b[i];});return siblings?// If two routes are siblings, we should try to match the earlier sibling\n// first. This allows people to have fine-grained control over the matching\n// behavior by simply putting routes with identical paths in the order they\n// want them tried.\na[a.length-1]-b[b.length-1]:// Otherwise, it doesn't really make sense to rank non-siblings by index,\n// so they sort equally.\n0;}function matchRouteBranch(branch,pathname){var routesMeta=branch.routesMeta;var matchedParams={};var matchedPathname=\"/\";var matches=[];for(var i=0;i<routesMeta.length;++i){var meta=routesMeta[i];var end=i===routesMeta.length-1;var remainingPathname=matchedPathname===\"/\"?pathname:pathname.slice(matchedPathname.length)||\"/\";var match=matchPath({path:meta.relativePath,caseSensitive:meta.caseSensitive,end:end},remainingPathname);if(!match)return null;Object.assign(matchedParams,match.params);var route=meta.route;matches.push({params:matchedParams,pathname:joinPaths([matchedPathname,match.pathname]),pathnameBase:joinPaths([matchedPathname,match.pathnameBase]),route:route});if(match.pathnameBase!==\"/\"){matchedPathname=joinPaths([matchedPathname,match.pathnameBase]);}}return matches;}/**\n * Renders the result of `matchRoutes()` into a React element.\n */function renderMatches(matches){return _renderMatches(matches);}function _renderMatches(matches,parentMatches){if(parentMatches===void 0){parentMatches=[];}if(matches==null)return null;return matches.reduceRight(function(outlet,match,index){return/*#__PURE__*/createElement(RouteContext.Provider,{children:match.route.element!==undefined?match.route.element:/*#__PURE__*/createElement(Outlet,null),value:{outlet:outlet,matches:parentMatches.concat(matches.slice(0,index+1))}});},null);}/**\n * A PathPattern is used to match on some portion of a URL pathname.\n */ /**\n * Performs pattern matching on a URL pathname and returns information about\n * the match.\n *\n * @see https://reactrouter.com/docs/en/v6/api#matchpath\n */function matchPath(pattern,pathname){if(typeof pattern===\"string\"){pattern={path:pattern,caseSensitive:false,end:true};}var _compilePath=compilePath(pattern.path,pattern.caseSensitive,pattern.end),_compilePath2=_slicedToArray(_compilePath,2),matcher=_compilePath2[0],paramNames=_compilePath2[1];var match=pathname.match(matcher);if(!match)return null;var matchedPathname=match[0];var pathnameBase=matchedPathname.replace(/(.)\\/+$/,\"$1\");var captureGroups=match.slice(1);var params=paramNames.reduce(function(memo,paramName,index){// We need to compute the pathnameBase here using the raw splat value\n// instead of using params[\"*\"] later because it will be decoded then\nif(paramName===\"*\"){var splatValue=captureGroups[index]||\"\";pathnameBase=matchedPathname.slice(0,matchedPathname.length-splatValue.length).replace(/(.)\\/+$/,\"$1\");}memo[paramName]=safelyDecodeURIComponent(captureGroups[index]||\"\",paramName);return memo;},{});return{params:params,pathname:matchedPathname,pathnameBase:pathnameBase,pattern:pattern};}function compilePath(path,caseSensitive,end){if(caseSensitive===void 0){caseSensitive=false;}if(end===void 0){end=true;}process.env.NODE_ENV!==\"production\"?warning(path===\"*\"||!path.endsWith(\"*\")||path.endsWith(\"/*\"),\"Route path \\\"\"+path+\"\\\" will be treated as if it were \"+(\"\\\"\"+path.replace(/\\*$/,\"/*\")+\"\\\" because the `*` character must \")+\"always follow a `/` in the pattern. To get rid of this warning, \"+(\"please change the route path to \\\"\"+path.replace(/\\*$/,\"/*\")+\"\\\".\")):void 0;var paramNames=[];var regexpSource=\"^\"+path.replace(/\\/*\\*?$/,\"\")// Ignore trailing / and /*, we'll handle it below\n.replace(/^\\/*/,\"/\")// Make sure it has a leading /\n.replace(/[\\\\.*+^$?{}|()[\\]]/g,\"\\\\$&\")// Escape special regex chars\n.replace(/:(\\w+)/g,function(_,paramName){paramNames.push(paramName);return\"([^\\\\/]+)\";});if(path.endsWith(\"*\")){paramNames.push(\"*\");regexpSource+=path===\"*\"||path===\"/*\"?\"(.*)$\"// Already matched the initial /, just match the rest\n:\"(?:\\\\/(.+)|\\\\/*)$\";// Don't include the / in params[\"*\"]\n}else{regexpSource+=end?\"\\\\/*$\"// When matching to the end, ignore trailing slashes\n:// Otherwise, match a word boundary or a proceeding /. The word boundary restricts\n// parent routes to matching only their own words and nothing more, e.g. parent\n// route \"/home\" should not match \"/home2\".\n\"(?:\\\\b|\\\\/|$)\";}var matcher=new RegExp(regexpSource,caseSensitive?undefined:\"i\");return[matcher,paramNames];}function safelyDecodeURIComponent(value,paramName){try{return decodeURIComponent(value);}catch(error){process.env.NODE_ENV!==\"production\"?warning(false,\"The value for the URL param \\\"\"+paramName+\"\\\" will not be decoded because\"+(\" the string \\\"\"+value+\"\\\" is a malformed URL segment. This is probably\")+(\" due to a bad percent encoding (\"+error+\").\")):void 0;return value;}}/**\n * Returns a resolved path object relative to the given pathname.\n *\n * @see https://reactrouter.com/docs/en/v6/api#resolvepath\n */function resolvePath(to,fromPathname){if(fromPathname===void 0){fromPathname=\"/\";}var _ref5=typeof to===\"string\"?parsePath(to):to,toPathname=_ref5.pathname,_ref5$search=_ref5.search,search=_ref5$search===void 0?\"\":_ref5$search,_ref5$hash=_ref5.hash,hash=_ref5$hash===void 0?\"\":_ref5$hash;var pathname=toPathname?toPathname.startsWith(\"/\")?toPathname:resolvePathname(toPathname,fromPathname):fromPathname;return{pathname:pathname,search:normalizeSearch(search),hash:normalizeHash(hash)};}function resolvePathname(relativePath,fromPathname){var segments=fromPathname.replace(/\\/+$/,\"\").split(\"/\");var relativeSegments=relativePath.split(\"/\");relativeSegments.forEach(function(segment){if(segment===\"..\"){// Keep the root \"\" segment so the pathname starts at /\nif(segments.length>1)segments.pop();}else if(segment!==\".\"){segments.push(segment);}});return segments.length>1?segments.join(\"/\"):\"/\";}function resolveTo(toArg,routePathnames,locationPathname){var to=typeof toArg===\"string\"?parsePath(toArg):toArg;var toPathname=toArg===\"\"||to.pathname===\"\"?\"/\":to.pathname;// If a pathname is explicitly provided in `to`, it should be relative to the\n// route context. This is explained in `Note on `<Link to>` values` in our\n// migration guide from v5 as a means of disambiguation between `to` values\n// that begin with `/` and those that do not. However, this is problematic for\n// `to` values that do not provide a pathname. `to` can simply be a search or\n// hash string, in which case we should assume that the navigation is relative\n// to the current location's pathname and *not* the route pathname.\nvar from;if(toPathname==null){from=locationPathname;}else{var routePathnameIndex=routePathnames.length-1;if(toPathname.startsWith(\"..\")){var toSegments=toPathname.split(\"/\");// Each leading .. segment means \"go up one route\" instead of \"go up one\n// URL segment\".  This is a key difference from how <a href> works and a\n// major reason we call this a \"to\" value instead of a \"href\".\nwhile(toSegments[0]===\"..\"){toSegments.shift();routePathnameIndex-=1;}to.pathname=toSegments.join(\"/\");}// If there are more \"..\" segments than parent routes, resolve relative to\n// the root / URL.\nfrom=routePathnameIndex>=0?routePathnames[routePathnameIndex]:\"/\";}var path=resolvePath(to,from);// Ensure the pathname has a trailing slash if the original to value had one.\nif(toPathname&&toPathname!==\"/\"&&toPathname.endsWith(\"/\")&&!path.pathname.endsWith(\"/\")){path.pathname+=\"/\";}return path;}function getToPathname(to){// Empty strings should be treated the same as / paths\nreturn to===\"\"||to.pathname===\"\"?\"/\":typeof to===\"string\"?parsePath(to).pathname:to.pathname;}function stripBasename(pathname,basename){if(basename===\"/\")return pathname;if(!pathname.toLowerCase().startsWith(basename.toLowerCase())){return null;}var nextChar=pathname.charAt(basename.length);if(nextChar&&nextChar!==\"/\"){// pathname does not start with basename/\nreturn null;}return pathname.slice(basename.length)||\"/\";}var joinPaths=function joinPaths(paths){return paths.join(\"/\").replace(/\\/\\/+/g,\"/\");};var normalizePathname=function normalizePathname(pathname){return pathname.replace(/\\/+$/,\"\").replace(/^\\/*/,\"/\");};var normalizeSearch=function normalizeSearch(search){return!search||search===\"?\"?\"\":search.startsWith(\"?\")?search:\"?\"+search;};var normalizeHash=function normalizeHash(hash){return!hash||hash===\"#\"?\"\":hash.startsWith(\"#\")?hash:\"#\"+hash;};///////////////////////////////////////////////////////////////////////////////\nexport{MemoryRouter,Navigate,Outlet,Route,Router,Routes,LocationContext as UNSAFE_LocationContext,NavigationContext as UNSAFE_NavigationContext,RouteContext as UNSAFE_RouteContext,createRoutesFromChildren,generatePath,matchPath,matchRoutes,renderMatches,resolvePath,useHref,useInRouterContext,useLocation,useMatch,useNavigate,useNavigationType,useOutlet,useOutletContext,useParams,useResolvedPath,useRoutes};","map":{"version":3,"sources":["../../../packages/react-router/index.tsx"],"names":["console","alreadyWarned","NavigationContext","React","LocationContext","RouteContext","outlet","matches","initialIndex","historyRef","createMemoryHistory","initialEntries","history","action","location","state","useInRouterContext","navigate","useNavigate","replace","useOutlet","props","basename","basenameProp","children","navigationType","NavigationType","static","staticProp","normalizePathname","navigationContext","navigator","locationProp","parsePath","pathname","search","hash","key","trailingPathname","stripBasename","useRoutes","createRoutesFromChildren","useResolvedPath","joinedPathname","toPathname","getToPathname","endsWithSlash","joinPaths","useLocation","matchPath","locationPathname","routePathnamesJson","JSON","match","activeRef","options","path","resolveTo","OutletContext","context","routeMatch","parentMatches","parentParams","parentPathname","parentPathnameBase","parentRoute","parentPath","warningOnce","locationFromContext","parsedLocationArg","remainingPathname","matchRoutes","_renderMatches","params","Object","pathnameBase","routes","element","route","caseSensitive","index","_","branches","flattenRoutes","rankRouteBranches","i","matchRouteBranch","parentsMeta","meta","relativePath","childrenIndex","routesMeta","score","computeScore","b","a","compareIndexes","paramRe","dynamicSegmentValue","indexRouteValue","emptySegmentValue","staticSegmentValue","splatPenalty","isSplat","s","segments","initialScore","segment","siblings","n","matchedParams","matchedPathname","end","React.createElement","pattern","compilePath","captureGroups","paramName","splatValue","memo","safelyDecodeURIComponent","paramNames","regexpSource","matcher","decodeURIComponent","fromPathname","resolvePathname","normalizeSearch","normalizeHash","relativeSegments","to","toArg","from","routePathnameIndex","routePathnames","toSegments","resolvePath","nextChar","paths"],"mappings":";;;;;;;;;sNAiBA,QAAA,CAAA,SAAA,CAAA,IAAA,CAAA,OAAA,CAA6D,CAC3D,GAAI,CAAJ,IAAA,CAAW,KAAM,IAAA,CAAA,KAAA,CAAN,OAAM,CAAN,CACZ,CAED,QAAA,CAAA,OAAA,CAAA,IAAA,CAAA,OAAA,CAAmD,CACjD,GAAI,CAAJ,IAAA,CAAW,CACT;AACA,GAAI,MAAA,CAAA,OAAA,GAAJ,WAAA,CAAoCA,OAAO,CAAPA,IAAAA,CAAAA,OAAAA,EAEpC,GAAI,CACF;AACA;AACA;AACA;AACA;AACA,KAAM,IAAA,CAAA,KAAA,CANJ,OAMI,CAAN,CANE;AAAJ,CAQE,MAAA,CAAA,CAAU,CAAA,CACb,CACF,CAED,GAAMC,CAAAA,aAAsC,CAA5C,EAAA,CACA,QAAA,CAAA,WAAA,CAAA,GAAA,CAAA,IAAA,CAAA,OAAA,CAAkE,CAChE,GAAI,CAAA,IAAA,EAAS,CAACA,aAAa,CAA3B,GAA2B,CAA3B,CAAkC,CAChCA,aAAa,CAAbA,GAAa,CAAbA,CAAAA,IAAAA,CACA,OAAA,CAAA,GAAA,CAAA,QAAA,GAAA,YAAA,CAAA,OAAO,CAAA,KAAA,CAAP,OAAO,CAAP,CAAA,IAAA,EAAA,CACD,CACF,CAAA;AAGD;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,G,GASMC,CAAAA,iBAAiB,CAAA,aAAGC,aAAAA,CAAAA,IAAAA,C,CAE1B,GAAA,OAAA,CAAA,GAAA,CAAA,QAAA,GAAA,YAAA,CAAa,CACXD,iBAAiB,CAAjBA,WAAAA,CAAAA,YAAAA,CACD,C,GAOKE,CAAAA,eAAe,CAAA,aAAGD,aAAAA,CAAAA,IAAAA,C,CAExB,GAAA,OAAA,CAAA,GAAA,CAAA,QAAA,GAAA,YAAA,CAAa,CACXC,eAAe,CAAfA,WAAAA,CAAAA,UAAAA,CACD,C,GAOKC,CAAAA,YAAY,CAAA,aAAG,aAAA,CAAwC,CAC3DC,MAAM,CADqD,IAAA,CAE3DC,OAAO,CAAE,EAFkD,CAAxC,C,CAKrB,GAAA,OAAA,CAAA,GAAA,CAAA,QAAA,GAAA,YAAA,CAAa,CACXF,YAAY,CAAZA,WAAAA,CAAAA,OAAAA,CACD,CAAA;AAGD;AACA;AASA;AACA;AACA;AACA;AACA,GACO,QAAA,CAAA,YAAA,CAAA,IAAA,CAKmC,IALb,CAAA,QAKa,CAAA,IAAA,CALb,QAKa,CALb,QAKa,CAAA,IAAA,CALb,QAKa,CALb,cAKa,CAAA,IAAA,CALb,cAKa,CADxCG,YACwC,CAAA,IAAA,CADxCA,YACwC,CACxC,GAAIC,CAAAA,UAAU,CAAGN,MAAjB,EAAA,CACA,GAAIM,UAAU,CAAVA,OAAAA,EAAJ,IAAA,CAAgC,CAC9BA,UAAU,CAAVA,OAAAA,CAAqBC,mBAAmB,CAAC,CAAEC,cAAF,CAAEA,cAAF,CAAkBH,YAAAA,CAAAA,YAAlB,CAAD,CAAxCC,CACD,CAED,GAAIG,CAAAA,OAAO,CAAGH,UAAU,CAAxB,OAAA,CANwC,cAOhB,QAAA,CAAe,CACrCI,MAAM,CAAED,OAAO,CADsB,MAAA,CAErCE,QAAQ,CAAEF,OAAO,CAACE,QAFmB,CAAf,CAPgB,wCAOpC,KAPoC,eAOpC,QAPoC,eAYxCX,eAAAA,CAAsB,iBAAMS,CAAAA,OAAO,CAAPA,MAAAA,CAA5BT,QAA4BS,CAAN,EAAtBT,CAAsD,CAAtDA,OAAsD,CAAtDA,CAAAA,CAEA,MAAA,aACE,aAAA,CAAA,MAAA,CAAA,CACE,QAAQ,CADV,QAAA,CAEE,QAAQ,CAFV,QAAA,CAGE,QAAQ,CAAEY,KAAK,CAHjB,QAAA,CAIE,cAAc,CAAEA,KAAK,CAJvB,MAAA,CAKE,SAAS,CAAEH,OALb,CAAA,CADF,CASD,CAQD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GACO,QAAA,CAAA,QAAA,CAAA,KAAA,CAA+D,IAA7C,CAAA,EAA6C,CAAA,KAAA,CAA7C,EAA6C,CAA7C,OAA6C,CAAA,KAAA,CAA7C,OAA6C,CAA9BG,KAA8B,CAAA,KAAA,CAA9BA,KAA8B,CACpE,CACEC,kBADF,EAAA,CAAA,OAAA,CAAA,GAAA,CAAA,QAAA,GAAA,YAAA,CAAA,SAAS,CAAA,KAAA,CAAA;AAGP;AAHF,qEAAS,CAAT,CAAA,SAAS,CAAT,KAAS,CAAT,CAAA,IAAA,EAAA,CAOA,OAAA,CAAA,GAAA,CAAA,QAAA,GAAA,YAAA,CAAA,OAAO,CACL,CAACb,UAAAA,CAAAA,iBAAAA,CAAAA,CADI,MAAA,CAEL,0EAAA,wEAAA,CAFF,0EAAO,CAAP,CAAA,IAAA,EAAA,CAOA,GAAIc,CAAAA,QAAQ,CAAGC,WAAf,EAAA,CACAf,SAAAA,CAAgB,UAAM,CACpBc,QAAQ,CAAA,EAAA,CAAK,CAAEE,OAAF,CAAEA,OAAF,CAAWJ,KAAAA,CAAAA,KAAX,CAAL,CAARE,CADFd,CAAAA,CAAAA,CAIA,MAAA,KAAA,CACD,CAMD;AACA;AACA;AACA;AACA,GACO,QAAA,CAAA,MAAA,CAAA,KAAA,CAA+D,CACpE,MAAOiB,CAAAA,SAAS,CAACC,KAAK,CAAtB,OAAgB,CAAhB,CACD,CA4BD;AACA;AACA;AACA;AACA,GACO,QAAA,CAAA,KAAA,CAAA,MAAA,CAEsB,CAC3B,OAAA,CAAA,GAAA,CAAA,QAAA,GAAA,YAAA,CAAA,SAAS,CAAA,KAAA,CAEP,uEAFF,kEAAS,CAAT,CAAA,SAAS,CAAT,KAAS,CAAT,CAKD,CAWD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GACO,QAAA,CAAA,MAAA,CAAA,KAAA,CAOoC,oBAAA,KAAA,CANzCC,QAMyC,CAN/BC,YAM+B,yBAPpB,GAOoB,+BAAA,KAAA,CALzCC,QAKyC,CALzCA,QAKyC,yBAPpB,IAOoB,gBAPpB,YAOoB,CAAA,KAAA,CAJzCV,QAIyC,sBAAA,KAAA,CAHzCW,cAGyC,CAHzCA,cAGyC,+BAHxBC,MAAc,CAJV,GAOoB,sBAPpB,SAOoB,CAAA,KAAA,CAPpB,SAOoB,cAAA,KAAA,CADzCC,MACyC,CADjCC,UACiC,uBADpB,KACoB,cACzC,CACE,CAACZ,kBADH,EAAA,CAAA,OAAA,CAAA,GAAA,CAAA,QAAA,GAAA,YAAA,CAAA,SAAS,CAAA,KAAA,CAEP,wDAFF,mDAAS,CAAT,CAAA,SAAS,CAAT,KAAS,CAAT,CAAA,IAAA,EAAA,CAMA,GAAIM,CAAAA,QAAQ,CAAGO,iBAAiB,CAAhC,YAAgC,CAAhC,CACA,GAAIC,CAAAA,iBAAiB,CAAG,OAAA,CACtB,iBAAO,CAAER,QAAF,CAAEA,QAAF,CAAYS,SAAZ,CAAYA,SAAZ,CAAuBJ,MAAM,CAAEC,UAA/B,CAAP,EADsB,CAEtB,CAAA,QAAA,CAAA,SAAA,CAFF,UAEE,CAFsB,CAAxB,CAKA,GAAI,MAAA,CAAA,YAAA,GAAJ,QAAA,CAAsC,CACpCI,YAAY,CAAGC,SAAS,CAAxBD,YAAwB,CAAxBA,CACD,CAfwC,kBAiBzC,YAjByC,qCAkBvCE,QAlBuC,CAkBvCA,QAlBuC,gCAiBrC,GAjBqC,0DAmBvCC,MAnBuC,CAmBvCA,MAnBuC,+BAiBrC,EAjBqC,uDAoBvCC,IApBuC,CAoBvCA,IApBuC,6BAiBrC,EAjBqC,sDAqBvCrB,KArBuC,CAqBvCA,KArBuC,8BAiBrC,IAjBqC,qDAsBvCsB,GAtBuC,CAsBvCA,GAtBuC,4BAsBjC,SAtBiC,mBAyBzC,GAAIvB,CAAAA,QAAQ,CAAG,OAAA,CAAc,UAAM,CACjC,GAAIwB,CAAAA,gBAAgB,CAAGC,aAAa,CAAA,QAAA,CAApC,QAAoC,CAApC,CAEA,GAAID,gBAAgB,EAApB,IAAA,CAA8B,CAC5B,MAAA,KAAA,CACD,CAED,MAAO,CACLJ,QAAQ,CADH,gBAAA,CAELC,MAFK,CAELA,MAFK,CAGLC,IAHK,CAGLA,IAHK,CAILrB,KAJK,CAILA,KAJK,CAKLsB,GAAAA,CAAAA,GALK,CAAP,CAPa,CAAA,CAcZ,CAAA,QAAA,CAAA,QAAA,CAAA,MAAA,CAAA,IAAA,CAAA,KAAA,CAdH,GAcG,CAdY,CAAf,CAgBA,OAAA,CAAA,GAAA,CAAA,QAAA,GAAA,YAAA,CAAA,OAAO,CACLvB,QAAQ,EADH,IAAA,CAEL,sBAAA,QAAA,CAAA,mCAAA,EAAA,KAAA,QAAA,CAAA,MAAA,CAAA,IAAA,CAAA,wCAAA,EAFF,kDAAO,CAAP,CAAA,IAAA,EAAA,CAOA,GAAIA,QAAQ,EAAZ,IAAA,CAAsB,CACpB,MAAA,KAAA,CACD,CAED,MAAA,aACE,aAAA,CAAC,iBAAD,CAAA,QAAA,CAAA,CAA4B,KAAK,CAAEgB,iBAAnC,CAAA,CAAA,aACE,aAAA,CAAC,eAAD,CAAA,QAAA,CAAA,CACE,QAAQ,CADV,QAAA,CAEE,KAAK,CAAE,CAAEhB,QAAF,CAAEA,QAAF,CAAYW,cAAAA,CAAAA,cAAZ,CAFT,CAAA,CADF,CADF,CAQD,CAOD;AACA;AACA;AACA;AACA;AACA,GACO,QAAA,CAAA,MAAA,CAAA,KAAA,CAGoC,IAHpB,CAAA,QAGoB,CAAA,KAAA,CAHpB,QAGoB,CADzCX,QACyC,CAAA,KAAA,CADzCA,QACyC,CACzC,MAAO0B,CAAAA,SAAS,CAACC,wBAAwB,CAAzB,QAAyB,CAAzB,CAAhB,QAAgB,CAAhB,CACD,CAAA;AAGD;AACA;AAEA;AACA;AACA;AACA;AACA;AACA,GACO,QAAA,CAAA,OAAA,CAAA,EAAA,CAAiC,CACtC,CACEzB,kBADF,EAAA,CAAA,OAAA,CAAA,GAAA,CAAA,QAAA,GAAA,YAAA,CAAA,SAAS,CAAA,KAAA,CAAA;AAGP;AAHF,oEAAS,CAAT,CAAA,SAAS,CAAT,KAAS,CAAT,CAAA,IAAA,EAAA,CADsC,gBAQRb,UAAAA,CAA9B,iBAA8BA,CARQ,CAQlC,QARkC,aAQlC,QARkC,CAQtB4B,SARsB,aAQtBA,SARsB,sBASLW,eAAe,CAAhD,EAAgD,CATV,CASlC,IATkC,kBASlC,IATkC,CASlC,QATkC,kBASlC,QATkC,CAShBP,MATgB,kBAShBA,MATgB,CAWtC,GAAIQ,CAAAA,cAAc,CAAlB,QAAA,CACA,GAAIrB,QAAQ,GAAZ,GAAA,CAAsB,CACpB,GAAIsB,CAAAA,UAAU,CAAGC,aAAa,CAA9B,EAA8B,CAA9B,CACA,GAAIC,CAAAA,aAAa,CAAGF,UAAU,EAAVA,IAAAA,EAAsBA,UAAU,CAAVA,QAAAA,CAA1C,GAA0CA,CAA1C,CACAD,cAAc,CACZT,QAAQ,GAARA,GAAAA,CACIZ,QAAQ,EAAIwB,aAAa,CAAA,GAAA,CAD7BZ,EACY,CADZA,CAEIa,SAAS,CAAC,CAAA,QAAA,CAHhBJ,QAGgB,CAAD,CAHfA,CAID,CAED,MAAO,CAAA,SAAS,CAAT,UAAA,CAAqB,CAAET,QAAQ,CAAV,cAAA,CAA4BC,MAA5B,CAA4BA,MAA5B,CAAoCC,IAAAA,CAAAA,IAApC,CAArB,CAAP,CACD,CAED;AACA;AACA;AACA;AACA,GACO,QAAA,CAAA,kBAAA,EAAuC,CAC5C,MAAOjC,CAAAA,UAAAA,CAAAA,eAAAA,CAAAA,EAAP,IAAA,CACD,CAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GACO,QAAA,CAAA,WAAA,EAAiC,CACtC,CACEa,kBADF,EAAA,CAAA,OAAA,CAAA,GAAA,CAAA,QAAA,GAAA,YAAA,CAAA,SAAS,CAAA,KAAA,CAAA;AAGP;AAHF,wEAAS,CAAT,CAAA,SAAS,CAAT,KAAS,CAAT,CAAA,IAAA,EAAA,CAOA,MAAOb,CAAAA,UAAAA,CAAAA,eAAAA,CAAAA,CAAP,QAAA,CACD,CAgDD;AACA;AACA;AACA;AACA;AACA,GACO,QAAA,CAAA,iBAAA,EAA6C,CAClD,MAAOA,CAAAA,UAAAA,CAAAA,eAAAA,CAAAA,CAAP,cAAA,CACD,CAED;AACA;AACA;AACA;AACA;AACA;AACA,GACO,QAAA,CAAA,QAAA,CAAA,OAAA,CAG0D,CAC/D,CACEa,kBADF,EAAA,CAAA,OAAA,CAAA,GAAA,CAAA,QAAA,GAAA,YAAA,CAAA,SAAS,CAAA,KAAA,CAAA;AAGP;AAHF,qEAAS,CAAT,CAAA,SAAS,CAAT,KAAS,CAAT,CAAA,IAAA,EAAA,CAD+D,iBAQ5CgC,WAAnB,EAR+D,CAQzDd,QARyD,cAQzDA,QARyD,CAS/D,MAAO/B,CAAAA,OAAAA,CACL,iBAAM8C,CAAAA,SAAS,CAAA,OAAA,CADV9C,QACU,CAAf,EADKA,CAEL,CAAA,QAAA,CAFF,OAEE,CAFKA,CAAP,CAID,CAED;AACA;AACA,G,CAWA;AACA;AACA;AACA;AACA;AACA,GACO,QAAA,CAAA,WAAA,EAAyC,CAC9C,CACEa,kBADF,EAAA,CAAA,OAAA,CAAA,GAAA,CAAA,QAAA,GAAA,YAAA,CAAA,SAAS,CAAA,KAAA,CAAA;AAGP;AAHF,wEAAS,CAAT,CAAA,SAAS,CAAT,KAAS,CAAT,CAAA,IAAA,EAAA,CAD8C,iBAQhBb,UAAAA,CAA9B,iBAA8BA,CARgB,CAQ1C,QAR0C,cAQ1C,QAR0C,CAQ9B4B,SAR8B,cAQ9BA,SAR8B,kBAS5B5B,UAAAA,CAAlB,YAAkBA,CAT4B,CASxCI,OATwC,cASxCA,OATwC,mBAUTyC,WAArC,EAV8C,CAU9BE,gBAV8B,eAUxChB,QAVwC,CAY9C,GAAIiB,CAAAA,kBAAkB,CAAGC,IAAI,CAAJA,SAAAA,CACvB7C,OAAO,CAAPA,GAAAA,CAAY8C,SAAAA,KAAK,QAAIA,CAAAA,KAAK,CAD5B,YACmB,EAAjB9C,CADuB6C,CAAzB,CAIA,GAAIE,CAAAA,SAAS,CAAGnD,MAAAA,CAAhB,KAAgBA,CAAhB,CACAA,SAAAA,CAAgB,UAAM,CACpBmD,SAAS,CAATA,OAAAA,CAAAA,IAAAA,CADFnD,CAAAA,CAAAA,CAIA,GAAIc,CAAAA,QAA0B,CAAG,WAAA,CAC/B,SAAA,EAAA,CAAA,OAAA,CAAoD,CAAA,GAAlCsC,OAAkC,GAAA,IAAA,EAAA,CAAA,CAAlCA,OAAkC,CAAP,EAA3BA,CAAkC,CAClD,OAAA,CAAA,GAAA,CAAA,QAAA,GAAA,YAAA,CAAA,OAAO,CACLD,SAAS,CADJ,OAAA,CAEL,+DAFF,mCAAO,CAAP,CAAA,IAAA,EAAA,CAMA,GAAI,CAACA,SAAS,CAAd,OAAA,CAAwB,OAExB,GAAI,MAAA,CAAA,EAAA,GAAJ,QAAA,CAA4B,CAC1BvB,SAAS,CAATA,EAAAA,CAAAA,EAAAA,EACA,OACD,CAED,GAAIyB,CAAAA,IAAI,CAAGC,SAAS,CAAA,EAAA,CAElBL,IAAI,CAAJA,KAAAA,CAFkB,kBAElBA,CAFkB,CAApB,gBAAoB,CAApB,CAMA,GAAI9B,QAAQ,GAAZ,GAAA,CAAsB,CACpBkC,IAAI,CAAJA,QAAAA,CAAgBT,SAAS,CAAC,CAAA,QAAA,CAAWS,IAAI,CAAzCA,QAA0B,CAAD,CAAzBA,CACD,CAED,CAAC,CAAC,CAACD,OAAO,CAAT,OAAA,CAAoBxB,SAAS,CAA7B,OAAA,CAAwCA,SAAS,CAAlD,IAAA,EAAA,IAAA,CAEEwB,OAAO,CAFT,KAAA,EAzB6B,CAAA,CA8B/B,CAAA,QAAA,CAAA,SAAA,CAAA,kBAAA,CA9BF,gBA8BE,CA9B+B,CAAjC,CAiCA,MAAA,CAAA,QAAA,CACD,CAED,GAAMG,CAAAA,aAAa,CAAA,aAAGvD,aAAAA,CAAtB,IAAsBA,CAAtB,CAEA;AACA;AACA;AACA;AACA,GACO,QAAA,CAAA,gBAAA,EAAwD,CAC7D,MAAOA,CAAAA,UAAAA,CAAP,aAAOA,CAAP,CACD,CAED;AACA;AACA;AACA;AACA;AACA,GACO,QAAA,CAAA,SAAA,CAAA,OAAA,CAAiE,CACtE,GAAIG,CAAAA,MAAM,CAAGH,UAAAA,CAAAA,YAAAA,CAAAA,CAAb,MAAA,CACA,GAAA,MAAA,CAAY,CACV,MAAA,aACE,aAAA,CAAC,aAAD,CAAA,QAAA,CAAA,CAAwB,KAAK,CAAEwD,OAA/B,CAAA,CADF,MACE,CADF,CAGD,CACD,MAAA,CAAA,MAAA,CACD,CAED;AACA;AACA;AACA;AACA;AACA,GACO,QAAA,CAAA,SAAA,EAIL,kBACkBxD,UAAAA,CAAlB,YAAkBA,CADlB,CACMI,OADN,cACMA,OADN,CAEA,GAAIqD,CAAAA,UAAU,CAAGrD,OAAO,CAACA,OAAO,CAAPA,MAAAA,CAAzB,CAAwB,CAAxB,CACA,MAAOqD,CAAAA,UAAU,CAAIA,UAAU,CAAd,MAAA,CAAjB,EAAA,CACD,CAED;AACA;AACA;AACA;AACA,GACO,QAAA,CAAA,eAAA,CAAA,EAAA,CAAuC,kBAC1BzD,UAAAA,CAAlB,YAAkBA,CAD0B,CACtCI,OADsC,cACtCA,OADsC,mBAEPyC,WAArC,EAF4C,CAE5BE,gBAF4B,eAEtChB,QAFsC,CAI5C,GAAIiB,CAAAA,kBAAkB,CAAGC,IAAI,CAAJA,SAAAA,CACvB7C,OAAO,CAAPA,GAAAA,CAAY8C,SAAAA,KAAK,QAAIA,CAAAA,KAAK,CAD5B,YACmB,EAAjB9C,CADuB6C,CAAzB,CAIA,MAAOjD,CAAAA,OAAAA,CACL,iBAAMsD,CAAAA,SAAS,CAAA,EAAA,CAAKL,IAAI,CAAJA,KAAAA,CAAL,kBAAKA,CAAL,CADVjD,gBACU,CAAf,EADKA,CAEL,CAAA,EAAA,CAAA,kBAAA,CAFF,gBAEE,CAFKA,CAAP,CAID,CAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GACO,QAAA,CAAA,SAAA,CAAA,MAAA,CAAA,WAAA,CAGsB,CAC3B,CACEa,kBADF,EAAA,CAAA,OAAA,CAAA,GAAA,CAAA,QAAA,GAAA,YAAA,CAAA,SAAS,CAAA,KAAA,CAAA;AAGP;AAHF,sEAAS,CAAT,CAAA,SAAS,CAAT,KAAS,CAAT,CAAA,IAAA,EAAA,CAD2B,iBAQMb,UAAAA,CAAjC,YAAiCA,CARN,CAQZ0D,aARY,cAQrBtD,OARqB,CAS3B,GAAIqD,CAAAA,UAAU,CAAGC,aAAa,CAACA,aAAa,CAAbA,MAAAA,CAA/B,CAA8B,CAA9B,CACA,GAAIC,CAAAA,YAAY,CAAGF,UAAU,CAAGA,UAAU,CAAb,MAAA,CAA7B,EAAA,CACA,GAAIG,CAAAA,cAAc,CAAGH,UAAU,CAAGA,UAAU,CAAb,QAAA,CAA/B,GAAA,CACA,GAAII,CAAAA,kBAAkB,CAAGJ,UAAU,CAAGA,UAAU,CAAb,YAAA,CAAnC,GAAA,CACA,GAAIK,CAAAA,WAAW,CAAGL,UAAU,EAAIA,UAAU,CAA1C,KAAA,CAEA,GAAA,OAAA,CAAA,GAAA,CAAA,QAAA,GAAA,YAAA,CAAa,CACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAIM,CAAAA,UAAU,CAAID,WAAW,EAAIA,WAAW,CAA3B,IAACA,EAAlB,EAAA,CACAE,WAAW,CAAA,cAAA,CAET,CAAA,WAAA,EAAgBD,UAAU,CAAVA,QAAAA,CAFP,GAEOA,CAFP,CAGT,kEAAA,KAAA,cAAA,CAAA,0BAAA,CAAA,UAAA,CAAA,eAAA,EAAA,sEAAA,CAAA,iEAAA,CAAA,+BAAA,EAAA,0CAAA,UAAA,CAAA,gBAAA,GAAA,WAMWA,UAAU,GAAVA,GAAAA,CAAAA,GAAAA,CAA8BA,UAA9BA,CANX,IAAA,EAHFC,MAGE,CAHS,CAAXA,CAWD,CAED,GAAIC,CAAAA,mBAAmB,CAAGpB,WAA1B,EAAA,CAEA,GAAA,CAAA,QAAA,CACA,GAAA,WAAA,CAAiB,CAAA,GAAA,CAAA,qBAAA,CACf,GAAIqB,CAAAA,iBAAiB,CACnB,MAAA,CAAA,WAAA,GAAA,QAAA,CAAkCpC,SAAS,CAA3C,WAA2C,CAA3C,CADF,WAAA,CAGA,EACE+B,kBAAkB,GAAlBA,GAAAA,GAAAA,CAAAA,qBAAAA,CACEK,iBAAiB,CADnBL,QAAAA,GAAAA,IAAAA,CAAAA,IAAAA,EAAAA,CACEK,qBAAAA,CAAAA,UAAAA,CAFJ,kBAEIA,CADFL,CADF,EAAA,OAAA,CAAA,GAAA,CAAA,QAAA,GAAA,YAAA,CAAA,SAAS,CAAA,KAAA,CAGP,4FAAA,iFAAA,EAAA,gEAAA,kBAAA,CAAA,KAAA,GAAA,kBAGmBK,iBAAiB,CAHpC,QAAA,CAHF,sCAGE,CAHO,CAAT,CAAA,SAAS,CAAT,KAAS,CAAT,CAAA,IAAA,EAAA,CASAvD,QAAQ,CAARA,iBAAAA,CAbF,CAAA,IAcO,CACLA,QAAQ,CAARA,mBAAAA,CACD,CAED,GAAIoB,CAAAA,QAAQ,CAAGpB,QAAQ,CAARA,QAAAA,EAAf,GAAA,CACA,GAAIwD,CAAAA,iBAAiB,CACnBN,kBAAkB,GAAlBA,GAAAA,CAAAA,QAAAA,CAEI9B,QAAQ,CAARA,KAAAA,CAAe8B,kBAAkB,CAAjC9B,MAAAA,GAHN,GAAA,CAIA,GAAI3B,CAAAA,OAAO,CAAGgE,WAAW,CAAA,MAAA,CAAS,CAAErC,QAAQ,CAAEoC,iBAAZ,CAAT,CAAzB,CAEA,GAAA,OAAA,CAAA,GAAA,CAAA,QAAA,GAAA,YAAA,CAAa,CACX,OAAA,CAAA,GAAA,CAAA,QAAA,GAAA,YAAA,CAAA,OAAO,CACLL,WAAW,EAAI1D,OAAO,EADjB,IAAA,CAAA,gCAE0BO,QAAQ,CAFlC,QAAA,CAE8CA,QAAQ,CAFtD,MAAA,CAEgEA,QAAQ,CAFxE,IAAA,CAAP,KAAO,CAAP,CAAA,IAAA,EAAA,CAKA,OAAA,CAAA,GAAA,CAAA,QAAA,GAAA,YAAA,CAAA,OAAO,CACLP,OAAO,EAAPA,IAAAA,EACEA,OAAO,CAACA,OAAO,CAAPA,MAAAA,CAARA,CAAO,CAAPA,CAAAA,KAAAA,CAAAA,OAAAA,GAFG,SAAA,CAGL,oCAAmCO,QAAQ,CAA3C,QAAA,CAAuDA,QAAQ,CAA/D,MAAA,CAAyEA,QAAQ,CAAjF,IAAA,CAAA,+BAAA,CAHF,sGAAO,CAAP,CAAA,IAAA,EAAA,CAMD,CAED,MAAO0D,CAAAA,cAAc,CACnBjE,OAAO,EACL,OAAO,CAAP,GAAA,CAAY8C,SAAAA,KAAK,QACf,CAAA,MAAM,CAAN,MAAA,CAAA,EAAA,CAAA,KAAA,CAAyB,CACvBoB,MAAM,CAAEC,MAAM,CAANA,MAAAA,CAAAA,EAAAA,CAAAA,YAAAA,CAAgCrB,KAAK,CADtB,MACfqB,CADe,CAEvBxC,QAAQ,CAAEa,SAAS,CAAC,CAAA,kBAAA,CAAqBM,KAAK,CAFvB,QAEH,CAAD,CAFI,CAGvBsB,YAAY,CACVtB,KAAK,CAALA,YAAAA,GAAAA,GAAAA,CAAAA,kBAAAA,CAEIN,SAAS,CAAC,CAAA,kBAAA,CAAqBM,KAAK,CAA3B,YAAC,CAAD,CANQ,CAAzB,CADe,EAAjB,CAFiB,CAArB,aAAqB,CAArB,CAcD,CAAA;AAGD;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GACO,QAAA,CAAA,wBAAA,CAAA,QAAA,CAEU,CACf,GAAIuB,CAAAA,MAAqB,CAAzB,EAAA,CAEAzE,QAAAA,CAAAA,OAAAA,CAAAA,QAAAA,CAAiC0E,SAAAA,OAAO,CAAI,CAC1C,GAAI,CAAA,aAAC1E,cAAAA,CAAL,OAAKA,CAAL,CAAoC,CAClC;AACA;AACA,OACD,CAED,GAAI0E,OAAO,CAAPA,IAAAA,GAAJ,QAAA,CAAqC,CACnC;AACAD,MAAM,CAANA,IAAAA,CAAAA,KAAAA,CAAAA,MAAAA,CAEEnC,wBAAwB,CAACoC,OAAO,CAAPA,KAAAA,CAF3BD,QAE0B,CAF1BA,EAIA,OACD,CAED,EACEC,OAAO,CAAPA,IAAAA,GADF,KAAA,EAAA,OAAA,CAAA,GAAA,CAAA,QAAA,GAAA,YAAA,CAAA,SAAS,CAAA,KAAA,CAAA,KAGL,MAAOA,CAAAA,OAAO,CAAd,IAAA,GAAA,QAAA,CAAmCA,OAAO,CAA1C,IAAA,CAAkDA,OAAO,CAAPA,IAAAA,CAH7C,IAAA,EAAT,wGAAS,CAAT,CAAA,SAAS,CAAT,KAAS,CAAT,CAAA,IAAA,EAAA,CAOA,GAAIC,CAAAA,KAAkB,CAAG,CACvBC,aAAa,CAAEF,OAAO,CAAPA,KAAAA,CADQ,aAAA,CAEvBA,OAAO,CAAEA,OAAO,CAAPA,KAAAA,CAFc,OAAA,CAGvBG,KAAK,CAAEH,OAAO,CAAPA,KAAAA,CAHgB,KAAA,CAIvBrB,IAAI,CAAEqB,OAAO,CAAPA,KAAAA,CAAcrB,IAJG,CAAzB,CAOA,GAAIqB,OAAO,CAAPA,KAAAA,CAAJ,QAAA,CAA4B,CAC1BC,KAAK,CAALA,QAAAA,CAAiBrC,wBAAwB,CAACoC,OAAO,CAAPA,KAAAA,CAA1CC,QAAyC,CAAzCA,CACD,CAEDF,MAAM,CAANA,IAAAA,CAAAA,KAAAA,EAlCFzE,CAAAA,EAqCA,MAAA,CAAA,MAAA,CACD,CAED;AACA;AACA,G,CAiBA;AACA;AACA;AACA;AACA,GACO,QAAA,CAAA,YAAA,CAAA,IAAA,CAAA,MAAA,CAAiE,CAAA,GAA7BsE,MAA6B,GAAA,IAAA,EAAA,CAAA,CAA7BA,MAA6B,CAAZ,EAAjBA,CAA6B,CACtE,MAAO,CAAA,IAAI,CAAJ,OAAA,CAAA,SAAA,CACe,SAAA,CAAA,CAAA,GAAA,CAAY,CAC9B,EAAUA,MAAM,CAANA,GAAM,CAANA,EAAV,IAAA,EAAA,OAAA,CAAA,GAAA,CAAA,QAAA,GAAA,YAAA,CAAA,SAAS,CAAA,KAAA,CAAA,cAAA,GAAA,CAAT,UAAS,CAAT,CAAA,SAAS,CAAT,KAAS,CAAT,CAAA,IAAA,EAAA,CACA,MAAOA,CAAAA,MAAM,CAAb,GAAa,CAAb,CAHG,CAAA,EAAA,OAAA,CAAA,QAAA,CAKcQ,SAAAA,CAAC,QAClBR,CAAAA,MAAM,CAANA,GAAM,CAANA,EAAAA,IAAAA,CAAAA,EAAAA,CAA2BA,MAAM,CAANA,GAAM,CAANA,CAAAA,OAAAA,CAAAA,MAAAA,CAN/B,GAM+BA,CADT,EALf,CAAP,CAQD,CAED;AACA;AACA,G,CAoBA;AACA;AACA;AACA;AACA,GACO,QAAA,CAAA,WAAA,CAAA,MAAA,CAAA,WAAA,CAAA,QAAA,CAIgB,CAAA,GADrBnD,QACqB,GAAA,IAAA,EAAA,CAAA,CADrBA,QACqB,CADV,GAAXA,CACqB,CACrB,GAAIR,CAAAA,QAAQ,CACV,MAAA,CAAA,WAAA,GAAA,QAAA,CAAkCmB,SAAS,CAA3C,WAA2C,CAA3C,CADF,WAAA,CAGA,GAAIC,CAAAA,QAAQ,CAAGK,aAAa,CAACzB,QAAQ,CAARA,QAAAA,EAAD,GAAA,CAA5B,QAA4B,CAA5B,CAEA,GAAIoB,QAAQ,EAAZ,IAAA,CAAsB,CACpB,MAAA,KAAA,CACD,CAED,GAAIgD,CAAAA,QAAQ,CAAGC,aAAa,CAA5B,MAA4B,CAA5B,CACAC,iBAAiB,CAAjBA,QAAiB,CAAjBA,CAEA,GAAI7E,CAAAA,OAAO,CAAX,IAAA,CACA,IAAK,GAAI8E,CAAAA,CAAC,CAAV,CAAA,CAAgB9E,OAAO,EAAPA,IAAAA,EAAmB8E,CAAC,CAAGH,QAAQ,CAA/C,MAAA,CAAwD,EAAxD,CAAA,CAA6D,CAC3D3E,OAAO,CAAG+E,gBAAgB,CAACJ,QAAQ,CAAT,CAAS,CAAT,CAA1B3E,QAA0B,CAA1BA,CACD,CAED,MAAA,CAAA,OAAA,CACD,CAeD,QAAA,CAAA,aAAA,CAAA,MAAA,CAAA,QAAA,CAAA,WAAA,CAAA,UAAA,CAKiB,CAAA,GAHf2E,QAGe,GAAA,IAAA,EAAA,CAAA,CAHfA,QAGe,CAHW,EAA1BA,CAGe,CAAA,GAFfK,WAEe,GAAA,IAAA,EAAA,CAAA,CAFfA,WAEe,CAFY,EAA3BA,CAEe,CAAA,GADfrB,UACe,GAAA,IAAA,EAAA,CAAA,CADfA,UACe,CADF,EAAbA,CACe,CACfU,MAAM,CAANA,OAAAA,CAAe,SAAA,KAAA,CAAA,KAAA,CAAkB,CAC/B,GAAIY,CAAAA,IAAe,CAAG,CACpBC,YAAY,CAAEX,KAAK,CAALA,IAAAA,EADM,EAAA,CAEpBC,aAAa,CAAED,KAAK,CAALA,aAAAA,GAFK,IAAA,CAGpBY,aAAa,CAHO,KAAA,CAIpBZ,KAAAA,CAAAA,KAJoB,CAAtB,CAOA,GAAIU,IAAI,CAAJA,YAAAA,CAAAA,UAAAA,CAAJ,GAAIA,CAAJ,CAAuC,CACrC,CACEA,IAAI,CAAJA,YAAAA,CAAAA,UAAAA,CADF,UACEA,CADF,CAAA,OAAA,CAAA,GAAA,CAAA,QAAA,GAAA,YAAA,CAAA,SAAS,CAAA,KAAA,CAEP,yBAAwBA,IAAI,CAA5B,YAAA,CAAA,uBAAA,EAAA,KAAA,UAAA,CAAA,gDAAA,EAFF,6DAAS,CAAT,CAAA,SAAS,CAAT,KAAS,CAAT,CAAA,IAAA,EAAA,CAOAA,IAAI,CAAJA,YAAAA,CAAoBA,IAAI,CAAJA,YAAAA,CAAAA,KAAAA,CAAwBtB,UAAU,CAAtDsB,MAAoBA,CAApBA,CACD,CAED,GAAIhC,CAAAA,IAAI,CAAGT,SAAS,CAAC,CAAA,UAAA,CAAayC,IAAI,CAAtC,YAAqB,CAAD,CAApB,CACA,GAAIG,CAAAA,UAAU,CAAGJ,WAAW,CAAXA,MAAAA,CApBc,IAoBdA,CAAjB,CApB+B;AAuB/B;AACA;AACA,GAAIT,KAAK,CAALA,QAAAA,EAAkBA,KAAK,CAALA,QAAAA,CAAAA,MAAAA,CAAtB,CAAA,CAAiD,CAC/C,EACEA,KAAK,CAALA,KAAAA,GADF,IAAA,EAAA,OAAA,CAAA,GAAA,CAAA,QAAA,GAAA,YAAA,CAAA,SAAS,CAAA,KAAA,CAEP,2DAAA,sCAAA,IAAA,CAFF,KAEE,CAFO,CAAT,CAAA,SAAS,CAAT,KAAS,CAAT,CAAA,IAAA,EAAA,CAMAK,aAAa,CAACL,KAAK,CAAN,QAAA,CAAA,QAAA,CAAA,UAAA,CAAbK,IAAa,CAAbA,CAhC6B,CAAA;AAoC/B;AACA,GAAIL,KAAK,CAALA,IAAAA,EAAAA,IAAAA,EAAsB,CAACA,KAAK,CAAhC,KAAA,CAAwC,CACtC,OACD,CAEDI,QAAQ,CAARA,IAAAA,CAAc,CAAE1B,IAAF,CAAEA,IAAF,CAAQoC,KAAK,CAAEC,YAAY,CAAA,IAAA,CAAOf,KAAK,CAAvC,KAA2B,CAA3B,CAAgDa,UAAAA,CAAAA,UAAhD,CAAdT,EAzCFN,CAAAA,EA4CA,MAAA,CAAA,QAAA,CACD,CAED,QAAA,CAAA,iBAAA,CAAA,QAAA,CAA0D,CACxDM,QAAQ,CAARA,IAAAA,CAAc,SAAA,CAAA,CAAA,CAAA,QACZ,CAAA,CAAC,CAAD,KAAA,GAAYY,CAAC,CAAb,KAAA,CACIA,CAAC,CAADA,KAAAA,CAAUC,CAAC,CADf,KAAA;AAAA,CAEIC,cAAc,CACZD,CAAC,CAADA,UAAAA,CAAAA,GAAAA,CAAiBP,SAAAA,IAAI,QAAIA,CAAAA,IAAI,CADjB,aACS,EAArBO,CADY,CAEZD,CAAC,CAADA,UAAAA,CAAAA,GAAAA,CAAiBN,SAAAA,IAAI,QAAIA,CAAAA,IAAI,CALrCN,aAK6B,EAArBY,CAFY,CAHN,EAAdZ,EAQD,CAED,GAAMe,CAAAA,OAAO,CAAb,QAAA,CACA,GAAMC,CAAAA,mBAAmB,CAAzB,CAAA,CACA,GAAMC,CAAAA,eAAe,CAArB,CAAA,CACA,GAAMC,CAAAA,iBAAiB,CAAvB,CAAA,CACA,GAAMC,CAAAA,kBAAkB,CAAxB,EAAA,CACA,GAAMC,CAAAA,YAAY,CAAG,CAArB,CAAA,CACA,GAAMC,CAAAA,OAAO,CAAIC,QAAXD,CAAAA,OAAWC,CAAAA,CAAD,QAAeA,CAAAA,CAAC,GAAhC,GAAgB,EAAhB,CAEA,QAAA,CAAA,YAAA,CAAA,IAAA,CAAA,KAAA,CAAwE,CACtE,GAAIC,CAAAA,QAAQ,CAAGjD,IAAI,CAAJA,KAAAA,CAAf,GAAeA,CAAf,CACA,GAAIkD,CAAAA,YAAY,CAAGD,QAAQ,CAA3B,MAAA,CACA,GAAIA,QAAQ,CAARA,IAAAA,CAAJ,OAAIA,CAAJ,CAA4B,CAC1BC,YAAY,EAAZA,YAAAA,CACD,CAED,GAAA,KAAA,CAAW,CACTA,YAAY,EAAZA,eAAAA,CACD,CAED,MAAOD,CAAAA,QAAQ,CAARA,MAAAA,CACGD,SAAAA,CAAC,QAAI,CAACD,OAAO,CADhBE,CACgB,CAAZ,EADJA,EAAAA,MAAAA,CAGH,SAAA,KAAA,CAAA,OAAA,QACEb,CAAAA,KAAK,EACJK,OAAO,CAAPA,IAAAA,CAAAA,OAAAA,EAAAA,mBAAAA,CAEGU,OAAO,GAAPA,EAAAA,CAAAA,iBAAAA,CAPHF,kBAII,CADP,EAHGA,CAAP,YAAOA,CAAP,CAYD,CAED,QAAA,CAAA,cAAA,CAAA,CAAA,CAAA,CAAA,CAA0D,CACxD,GAAIG,CAAAA,QAAQ,CACVb,CAAC,CAADA,MAAAA,GAAaD,CAAC,CAAdC,MAAAA,EAAyBA,CAAC,CAADA,KAAAA,CAAAA,CAAAA,CAAW,CAAXA,CAAAA,EAAAA,KAAAA,CAAqB,SAAA,CAAA,CAAA,CAAA,QAAUc,CAAAA,CAAC,GAAKf,CAAC,CADjE,CACiE,CAAjB,EAArBC,CAD3B,CAGA,MAAOa,CAAAA,QAAQ,CAAA;AAEX;AACA;AACA;AACAb,CAAC,CAACA,CAAC,CAADA,MAAAA,CAAFA,CAAC,CAADA,CAAkBD,CAAC,CAACA,CAAC,CAADA,MAAAA,CALT,CAKQ,CALR,CAAA;AAOX;AAPJ,CAAA,CASD,CAED,QAAA,CAAA,gBAAA,CAAA,MAAA,CAAA,QAAA,CAGiC,IACzBH,CAAAA,UADyB,CAC/B,MAD+B,CACzBA,UADyB,CAG/B,GAAImB,CAAAA,aAAa,CAAjB,EAAA,CACA,GAAIC,CAAAA,eAAe,CAAnB,GAAA,CACA,GAAIxG,CAAAA,OAAqB,CAAzB,EAAA,CACA,IAAK,GAAI8E,CAAAA,CAAC,CAAV,CAAA,CAAgBA,CAAC,CAAGM,UAAU,CAA9B,MAAA,CAAuC,EAAvC,CAAA,CAA4C,CAC1C,GAAIH,CAAAA,IAAI,CAAGG,UAAU,CAArB,CAAqB,CAArB,CACA,GAAIqB,CAAAA,GAAG,CAAG3B,CAAC,GAAKM,UAAU,CAAVA,MAAAA,CAAhB,CAAA,CACA,GAAIrB,CAAAA,iBAAiB,CACnByC,eAAe,GAAfA,GAAAA,CAAAA,QAAAA,CAEI7E,QAAQ,CAARA,KAAAA,CAAe6E,eAAe,CAA9B7E,MAAAA,GAHN,GAAA,CAIA,GAAImB,CAAAA,KAAK,CAAGJ,SAAS,CACnB,CAAEO,IAAI,CAAEgC,IAAI,CAAZ,YAAA,CAA2BT,aAAa,CAAES,IAAI,CAA9C,aAAA,CAA8DwB,GAAAA,CAAAA,GAA9D,CADmB,CAArB,iBAAqB,CAArB,CAKA,GAAI,CAAJ,KAAA,CAAY,MAAA,KAAA,CAEZtC,MAAM,CAANA,MAAAA,CAAAA,aAAAA,CAA6BrB,KAAK,CAAlCqB,MAAAA,EAEA,GAAII,CAAAA,KAAK,CAAGU,IAAI,CAAhB,KAAA,CAEAjF,OAAO,CAAPA,IAAAA,CAAa,CACXkE,MAAM,CADK,aAAA,CAEXvC,QAAQ,CAAEa,SAAS,CAAC,CAAA,eAAA,CAAkBM,KAAK,CAFhC,QAES,CAAD,CAFR,CAGXsB,YAAY,CAAE5B,SAAS,CAAC,CAAA,eAAA,CAAkBM,KAAK,CAHpC,YAGa,CAAD,CAHZ,CAIXyB,KAAAA,CAAAA,KAJW,CAAbvE,EAOA,GAAI8C,KAAK,CAALA,YAAAA,GAAJ,GAAA,CAAgC,CAC9B0D,eAAe,CAAGhE,SAAS,CAAC,CAAA,eAAA,CAAkBM,KAAK,CAAnD0D,YAA4B,CAAD,CAA3BA,CACD,CACF,CAED,MAAA,CAAA,OAAA,CACD,CAED;AACA;AACA,GACO,QAAA,CAAA,aAAA,CAAA,OAAA,CAEsB,CAC3B,MAAOvC,CAAAA,cAAc,CAArB,OAAqB,CAArB,CACD,CAED,QAAA,CAAA,cAAA,CAAA,OAAA,CAAA,aAAA,CAG6B,CAAA,GAD3BX,aAC2B,GAAA,IAAA,EAAA,CAAA,CAD3BA,aAC2B,CADG,EAA9BA,CAC2B,CAC3B,GAAItD,OAAO,EAAX,IAAA,CAAqB,MAAA,KAAA,CAErB,MAAO,CAAA,OAAO,CAAP,WAAA,CAAoB,SAAA,MAAA,CAAA,KAAA,CAAA,KAAA,CAA0B,CACnD,MAAA,aACE,aAAA,CAAC,YAAD,CAAA,QAAA,CAAA,CACE,QAAQ,CACN8C,KAAK,CAALA,KAAAA,CAAAA,OAAAA,GAAAA,SAAAA,CAAoCA,KAAK,CAALA,KAAAA,CAApCA,OAAAA,CAAAA,aAA0D4D,aAAAA,CAAAA,MAAAA,CAF9D,IAE8DA,CAF9D,CAIE,KAAK,CAAE,CACL3G,MADK,CACLA,MADK,CAELC,OAAO,CAAEsD,aAAa,CAAbA,MAAAA,CAAqBtD,OAAO,CAAPA,KAAAA,CAAAA,CAAAA,CAAiByE,KAAK,CAA3CnB,CAAqBtD,CAArBsD,CAFJ,CAJT,CAAA,CADF,CADK,CAAA,CAAP,IAAO,CAAP,CAaD,CAED;AACA;AACA,G,CA6CA;AACA;AACA;AACA;AACA;AACA,GACO,QAAA,CAAA,SAAA,CAAA,OAAA,CAAA,QAAA,CAMuB,CAC5B,GAAI,MAAA,CAAA,OAAA,GAAJ,QAAA,CAAiC,CAC/BqD,OAAO,CAAG,CAAE1D,IAAI,CAAN,OAAA,CAAiBuB,aAAa,CAA9B,KAAA,CAAuCiC,GAAG,CAAE,IAA5C,CAAVE,CACD,CAH2B,iBAKAC,WAAW,CACrCD,OAAO,CAD8B,IAAA,CAErCA,OAAO,CAF8B,aAAA,CAGrCA,OAAO,CAHT,GAAuC,CALX,8CAKxB,OALwB,kBAKxB,UALwB,kBAW5B,GAAI7D,CAAAA,KAAK,CAAGnB,QAAQ,CAARA,KAAAA,CAAZ,OAAYA,CAAZ,CACA,GAAI,CAAJ,KAAA,CAAY,MAAA,KAAA,CAEZ,GAAI6E,CAAAA,eAAe,CAAG1D,KAAK,CAA3B,CAA2B,CAA3B,CACA,GAAIsB,CAAAA,YAAY,CAAGoC,eAAe,CAAfA,OAAAA,CAAAA,SAAAA,CAAnB,IAAmBA,CAAnB,CACA,GAAIK,CAAAA,aAAa,CAAG/D,KAAK,CAALA,KAAAA,CAApB,CAAoBA,CAApB,CACA,GAAIoB,CAAAA,MAAc,CAAG,UAAU,CAAV,MAAA,CACnB,SAAA,IAAA,CAAA,SAAA,CAAA,KAAA,CAA4B,CAC1B;AACA;AACA,GAAI4C,SAAS,GAAb,GAAA,CAAuB,CACrB,GAAIC,CAAAA,UAAU,CAAGF,aAAa,CAAbA,KAAa,CAAbA,EAAjB,EAAA,CACAzC,YAAY,CAAGoC,eAAe,CAAfA,KAAAA,CAAAA,CAAAA,CACHA,eAAe,CAAfA,MAAAA,CAAyBO,UAAU,CADhCP,MAAAA,EAAAA,OAAAA,CAAAA,SAAAA,CAAfpC,IAAeoC,CAAfpC,CAGD,CAED4C,IAAI,CAAJA,SAAI,CAAJA,CAAkBC,wBAAwB,CACxCJ,aAAa,CAAbA,KAAa,CAAbA,EADwC,EAAA,CAA1CG,SAA0C,CAA1CA,CAIA,MAAA,CAAA,IAAA,CAfiB,CAAA,CAArB,EAAqB,CAArB,CAoBA,MAAO,CACL9C,MADK,CACLA,MADK,CAELvC,QAAQ,CAFH,eAAA,CAGLyC,YAHK,CAGLA,YAHK,CAILuC,OAAAA,CAAAA,OAJK,CAAP,CAMD,CAED,QAAA,CAAA,WAAA,CAAA,IAAA,CAAA,aAAA,CAAA,GAAA,CAIsB,CAAA,GAFpBnC,aAEoB,GAAA,IAAA,EAAA,CAAA,CAFpBA,aAEoB,CAFJ,KAAhBA,CAEoB,CAAA,GADpBiC,GACoB,GAAA,IAAA,EAAA,CAAA,CADpBA,GACoB,CADd,IAANA,CACoB,CACpB,OAAA,CAAA,GAAA,CAAA,QAAA,GAAA,YAAA,CAAA,OAAO,CACLxD,IAAI,GAAJA,GAAAA,EAAgB,CAACA,IAAI,CAAJA,QAAAA,CAAjBA,GAAiBA,CAAjBA,EAAuCA,IAAI,CAAJA,QAAAA,CADlC,IACkCA,CADlC,CAEL,gBAAA,IAAA,CAAA,mCAAA,EAAA,KACMA,IAAI,CAAJA,OAAAA,CAAAA,KAAAA,CADN,IACMA,CADN,CAAA,oCAAA,EAAA,kEAAA,EAAA,qCAGsCA,IAAI,CAAJA,OAAAA,CAAAA,KAAAA,CAHtC,IAGsCA,CAHtC,CAFF,KAEE,CAFK,CAAP,CAAA,IAAA,EAAA,CAQA,GAAIiE,CAAAA,UAAoB,CAAxB,EAAA,CACA,GAAIC,CAAAA,YAAY,CACd,IACA,IAAI,CAAJ,OAAA,CAAA,SAAA,CAAA,EAAA,CAAA;AAAA,CAAA,OAAA,CAAA,MAAA,CAAA,GAAA,CAAA;AAAA,CAAA,OAAA,CAAA,qBAAA,CAAA,MAAA,CAAA;AAAA,CAAA,OAAA,CAAA,SAAA,CAIsB,SAAA,CAAA,CAAA,SAAA,CAAkC,CACpDD,UAAU,CAAVA,IAAAA,CAAAA,SAAAA,EACA,MAAA,WAAA,CARN,CAEE,CAFF,CAWA,GAAIjE,IAAI,CAAJA,QAAAA,CAAJ,GAAIA,CAAJ,CAAwB,CACtBiE,UAAU,CAAVA,IAAAA,CAAAA,GAAAA,EACAC,YAAY,EACV,IAAI,GAAJ,GAAA,EAAgBlE,IAAI,GAApB,IAAA,CAAA,OAAA;AAAA,CAHoB,mBAEtBkE,CAFsB;AAAxB,CAAA,IAMO,CACLA,YAAY,EAAIV,GAAG,CAAA,OAAA;AAAA,CAAA;AAGf;AACA;AAJJU,eAAAA,CAMD,CAED,GAAIC,CAAAA,OAAO,CAAG,GAAA,CAAA,MAAA,CAAA,YAAA,CAAyB5C,aAAa,CAAA,SAAA,CAApD,GAAc,CAAd,CAEA,MAAO,CAAA,OAAA,CAAP,UAAO,CAAP,CACD,CAED,QAAA,CAAA,wBAAA,CAAA,KAAA,CAAA,SAAA,CAAoE,CAClE,GAAI,CACF,MAAO6C,CAAAA,kBAAkB,CAAzB,KAAyB,CAAzB,CADF,CAEE,MAAA,KAAA,CAAc,CACd,OAAA,CAAA,GAAA,CAAA,QAAA,GAAA,YAAA,CAAA,OAAO,CAAA,KAAA,CAEL,iCAAA,SAAA,CAAA,gCAAA,EAAA,iBAAA,KAAA,CAAA,iDAAA,GAAA,mCAAA,KAAA,CAFF,IAEE,CAFK,CAAP,CAAA,IAAA,EAAA,CAOA,MAAA,CAAA,KAAA,CACD,CACF,CAED;AACA;AACA;AACA;AACA,GACO,QAAA,CAAA,WAAA,CAAA,EAAA,CAAA,YAAA,CAAuD,CAAA,GAA1BC,YAA0B,GAAA,IAAA,EAAA,CAAA,CAA1BA,YAA0B,CAAX,GAAfA,CAA0B,CAAA,UAKxD,MAAA,CAAA,EAAA,GAAA,QAAA,CAAyB5F,SAAS,CAAlC,EAAkC,CAAlC,CAJJ,EAD4D,CACxD,UADwD,OAE1DC,QAF0D,oBAG1DC,MAH0D,CAG1DA,MAH0D,uBACxD,EADwD,+BAI1DC,IAJ0D,CAI1DA,IAJ0D,qBAInD,EAJmD,YAO5D,GAAIF,CAAAA,QAAQ,CAAGU,UAAU,CACrBA,UAAU,CAAVA,UAAAA,CAAAA,GAAAA,EAAAA,UAAAA,CAEEkF,eAAe,CAAA,UAAA,CAHI,YAGJ,CAHI,CAAzB,YAAA,CAMA,MAAO,CACL5F,QADK,CACLA,QADK,CAELC,MAAM,CAAE4F,eAAe,CAFlB,MAEkB,CAFlB,CAGL3F,IAAI,CAAE4F,aAAa,CAAA,IAAA,CAHd,CAAP,CAKD,CAED,QAAA,CAAA,eAAA,CAAA,YAAA,CAAA,YAAA,CAA6E,CAC3E,GAAIvB,CAAAA,QAAQ,CAAGoB,YAAY,CAAZA,OAAAA,CAAAA,MAAAA,CAAAA,EAAAA,EAAAA,KAAAA,CAAf,GAAeA,CAAf,CACA,GAAII,CAAAA,gBAAgB,CAAGxC,YAAY,CAAZA,KAAAA,CAAvB,GAAuBA,CAAvB,CAEAwC,gBAAgB,CAAhBA,OAAAA,CAAyBtB,SAAAA,OAAO,CAAI,CAClC,GAAIA,OAAO,GAAX,IAAA,CAAsB,CACpB;AACA,GAAIF,QAAQ,CAARA,MAAAA,CAAJ,CAAA,CAAyBA,QAAQ,CAARA,GAAAA,GAF3B,CAAA,IAGO,IAAIE,OAAO,GAAX,GAAA,CAAqB,CAC1BF,QAAQ,CAARA,IAAAA,CAAAA,OAAAA,EACD,CANHwB,CAAAA,EASA,MAAOxB,CAAAA,QAAQ,CAARA,MAAAA,CAAAA,CAAAA,CAAsBA,QAAQ,CAARA,IAAAA,CAAtBA,GAAsBA,CAAtBA,CAAP,GAAA,CACD,CAED,QAAA,CAAA,SAAA,CAAA,KAAA,CAAA,cAAA,CAAA,gBAAA,CAIQ,CACN,GAAIyB,CAAAA,EAAE,CAAG,MAAA,CAAA,KAAA,GAAA,QAAA,CAA4BjG,SAAS,CAArC,KAAqC,CAArC,CAAT,KAAA,CACA,GAAIW,CAAAA,UAAU,CAAGuF,KAAK,GAALA,EAAAA,EAAgBD,EAAE,CAAFA,QAAAA,GAAhBC,EAAAA,CAAAA,GAAAA,CAA2CD,EAAE,CAFxD,QAEN,CAFM;AAKN;AACA;AACA;AACA;AACA;AACA;AACA,GAAA,CAAA,IAAA,CACA,GAAItF,UAAU,EAAd,IAAA,CAAwB,CACtBwF,IAAI,CAAJA,gBAAAA,CADF,CAAA,IAEO,CACL,GAAIC,CAAAA,kBAAkB,CAAGC,cAAc,CAAdA,MAAAA,CAAzB,CAAA,CAEA,GAAI1F,UAAU,CAAVA,UAAAA,CAAJ,IAAIA,CAAJ,CAAiC,CAC/B,GAAI2F,CAAAA,UAAU,CAAG3F,UAAU,CAAVA,KAAAA,CADc,GACdA,CAAjB,CAD+B;AAI/B;AACA;AACA,MAAO2F,UAAU,CAAVA,CAAU,CAAVA,GAAP,IAAA,CAA+B,CAC7BA,UAAU,CAAVA,KAAAA,GACAF,kBAAkB,EAAlBA,CAAAA,CACD,CAEDH,EAAE,CAAFA,QAAAA,CAAcK,UAAU,CAAVA,IAAAA,CAAdL,GAAcK,CAAdL,CAdG,CAAA;AAkBL;AACAE,IAAI,CAAGC,kBAAkB,EAAlBA,CAAAA,CAA0BC,cAAc,CAAxCD,kBAAwC,CAAxCA,CAAPD,GAAAA,CACD,CAED,GAAI5E,CAAAA,IAAI,CAAGgF,WAAW,CAAA,EAAA,CApChB,IAoCgB,CAAtB,CApCM;AAuCN,GACE5F,UAAU,EACVA,UAAU,GADVA,GAAAA,EAEAA,UAAU,CAAVA,QAAAA,CAFAA,GAEAA,CAFAA,EAGA,CAACY,IAAI,CAAJA,QAAAA,CAAAA,QAAAA,CAJH,GAIGA,CAJH,CAKE,CACAA,IAAI,CAAJA,QAAAA,EAAAA,GAAAA,CACD,CAED,MAAA,CAAA,IAAA,CACD,CAED,QAAA,CAAA,aAAA,CAAA,EAAA,CAAmD,CACjD;AACA,MAAO0E,CAAAA,EAAE,GAAFA,EAAAA,EAAcA,EAAD,CAAA,QAACA,GAAdA,EAAAA,CAAAA,GAAAA,CAEH,MAAA,CAAA,EAAA,GAAA,QAAA,CACAjG,SAAS,CAATA,EAAS,CAATA,CADA,QAAA,CAEAiG,EAAE,CAJN,QAAA,CAKD,CAED,QAAA,CAAA,aAAA,CAAA,QAAA,CAAA,QAAA,CAA0E,CACxE,GAAI5G,QAAQ,GAAZ,GAAA,CAAsB,MAAA,CAAA,QAAA,CAEtB,GAAI,CAACY,QAAQ,CAARA,WAAAA,GAAAA,UAAAA,CAAkCZ,QAAQ,CAA/C,WAAuCA,EAAlCY,CAAL,CAAgE,CAC9D,MAAA,KAAA,CACD,CAED,GAAIuG,CAAAA,QAAQ,CAAGvG,QAAQ,CAARA,MAAAA,CAAgBZ,QAAQ,CAAvC,MAAeY,CAAf,CACA,GAAIuG,QAAQ,EAAIA,QAAQ,GAAxB,GAAA,CAAkC,CAChC;AACA,MAAA,KAAA,CACD,CAED,MAAOvG,CAAAA,QAAQ,CAARA,KAAAA,CAAeZ,QAAQ,CAAvBY,MAAAA,GAAP,GAAA,CACD,CAED,GAAMa,CAAAA,SAAS,CAAI2F,QAAb3F,CAAAA,SAAa2F,CAAAA,KAAD,QAChBA,CAAAA,KAAK,CAALA,IAAAA,CAAAA,GAAAA,EAAAA,OAAAA,CAAAA,QAAAA,CADF,GACEA,CADgB,EAAlB,CAGA,GAAM7G,CAAAA,iBAAiB,CAAIK,QAArBL,CAAAA,iBAAqBK,CAAAA,QAAD,QACxBA,CAAAA,QAAQ,CAARA,OAAAA,CAAAA,MAAAA,CAAAA,EAAAA,EAAAA,OAAAA,CAAAA,MAAAA,CADF,GACEA,CADwB,EAA1B,CAGA,GAAM6F,CAAAA,eAAe,CAAI5F,QAAnB4F,CAAAA,eAAmB5F,CAAAA,MAAD,QACtB,CAAA,MAAA,EAAWA,MAAM,GAAjB,GAAA,CAAA,EAAA,CAEIA,MAAM,CAANA,UAAAA,CAAAA,GAAAA,EAAAA,MAAAA,CAEA,IALN,MAAwB,EAAxB,CAOA,GAAM6F,CAAAA,aAAa,CAAI5F,QAAjB4F,CAAAA,aAAiB5F,CAAAA,IAAD,QACpB,CAAA,IAAA,EAASA,IAAI,GAAb,GAAA,CAAA,EAAA,CAA6BA,IAAI,CAAJA,UAAAA,CAAAA,GAAAA,EAAAA,IAAAA,CAA8B,IAD7D,IAAsB,EAAtB,CAAA","sourcesContent":["import * as React from \"react\";\nimport type {\n  History,\n  InitialEntry,\n  Location,\n  MemoryHistory,\n  Path,\n  To\n} from \"history\";\nimport {\n  Action as NavigationType,\n  createMemoryHistory,\n  parsePath\n} from \"history\";\n\nexport type { Location, Path, To, NavigationType };\n\nfunction invariant(cond: any, message: string): asserts cond {\n  if (!cond) throw new Error(message);\n}\n\nfunction warning(cond: any, message: string): void {\n  if (!cond) {\n    // eslint-disable-next-line no-console\n    if (typeof console !== \"undefined\") console.warn(message);\n\n    try {\n      // Welcome to debugging React Router!\n      //\n      // This error is thrown as a convenience so you can more easily\n      // find the source for a warning that appears in the console by\n      // enabling \"pause on exceptions\" in your JavaScript debugger.\n      throw new Error(message);\n      // eslint-disable-next-line no-empty\n    } catch (e) {}\n  }\n}\n\nconst alreadyWarned: Record<string, boolean> = {};\nfunction warningOnce(key: string, cond: boolean, message: string) {\n  if (!cond && !alreadyWarned[key]) {\n    alreadyWarned[key] = true;\n    warning(false, message);\n  }\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// CONTEXT\n///////////////////////////////////////////////////////////////////////////////\n\n/**\n * A Navigator is a \"location changer\"; it's how you get to different locations.\n *\n * Every history instance conforms to the Navigator interface, but the\n * distinction is useful primarily when it comes to the low-level <Router> API\n * where both the location and a navigator must be provided separately in order\n * to avoid \"tearing\" that may occur in a suspense-enabled app if the action\n * and/or location were to be read directly from the history instance.\n */\nexport type Navigator = Pick<History, \"go\" | \"push\" | \"replace\" | \"createHref\">;\n\ninterface NavigationContextObject {\n  basename: string;\n  navigator: Navigator;\n  static: boolean;\n}\n\nconst NavigationContext = React.createContext<NavigationContextObject>(null!);\n\nif (__DEV__) {\n  NavigationContext.displayName = \"Navigation\";\n}\n\ninterface LocationContextObject {\n  location: Location;\n  navigationType: NavigationType;\n}\n\nconst LocationContext = React.createContext<LocationContextObject>(null!);\n\nif (__DEV__) {\n  LocationContext.displayName = \"Location\";\n}\n\ninterface RouteContextObject {\n  outlet: React.ReactElement | null;\n  matches: RouteMatch[];\n}\n\nconst RouteContext = React.createContext<RouteContextObject>({\n  outlet: null,\n  matches: []\n});\n\nif (__DEV__) {\n  RouteContext.displayName = \"Route\";\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// COMPONENTS\n///////////////////////////////////////////////////////////////////////////////\n\nexport interface MemoryRouterProps {\n  basename?: string;\n  children?: React.ReactNode;\n  initialEntries?: InitialEntry[];\n  initialIndex?: number;\n}\n\n/**\n * A <Router> that stores all entries in memory.\n *\n * @see https://reactrouter.com/docs/en/v6/api#memoryrouter\n */\nexport function MemoryRouter({\n  basename,\n  children,\n  initialEntries,\n  initialIndex\n}: MemoryRouterProps): React.ReactElement {\n  let historyRef = React.useRef<MemoryHistory>();\n  if (historyRef.current == null) {\n    historyRef.current = createMemoryHistory({ initialEntries, initialIndex });\n  }\n\n  let history = historyRef.current;\n  let [state, setState] = React.useState({\n    action: history.action,\n    location: history.location\n  });\n\n  React.useLayoutEffect(() => history.listen(setState), [history]);\n\n  return (\n    <Router\n      basename={basename}\n      children={children}\n      location={state.location}\n      navigationType={state.action}\n      navigator={history}\n    />\n  );\n}\n\nexport interface NavigateProps {\n  to: To;\n  replace?: boolean;\n  state?: any;\n}\n\n/**\n * Changes the current location.\n *\n * Note: This API is mostly useful in React.Component subclasses that are not\n * able to use hooks. In functional components, we recommend you use the\n * `useNavigate` hook instead.\n *\n * @see https://reactrouter.com/docs/en/v6/api#navigate\n */\nexport function Navigate({ to, replace, state }: NavigateProps): null {\n  invariant(\n    useInRouterContext(),\n    // TODO: This error is probably because they somehow have 2 versions of\n    // the router loaded. We can help them understand how to avoid that.\n    `<Navigate> may be used only in the context of a <Router> component.`\n  );\n\n  warning(\n    !React.useContext(NavigationContext).static,\n    `<Navigate> must not be used on the initial render in a <StaticRouter>. ` +\n      `This is a no-op, but you should modify your code so the <Navigate> is ` +\n      `only ever rendered in response to some user interaction or state change.`\n  );\n\n  let navigate = useNavigate();\n  React.useEffect(() => {\n    navigate(to, { replace, state });\n  });\n\n  return null;\n}\n\nexport interface OutletProps {\n  context?: unknown;\n}\n\n/**\n * Renders the child route's element, if there is one.\n *\n * @see https://reactrouter.com/docs/en/v6/api#outlet\n */\nexport function Outlet(props: OutletProps): React.ReactElement | null {\n  return useOutlet(props.context);\n}\n\nexport interface RouteProps {\n  caseSensitive?: boolean;\n  children?: React.ReactNode;\n  element?: React.ReactNode | null;\n  index?: boolean;\n  path?: string;\n}\n\nexport interface PathRouteProps {\n  caseSensitive?: boolean;\n  children?: React.ReactNode;\n  element?: React.ReactNode | null;\n  index?: false;\n  path: string;\n}\n\nexport interface LayoutRouteProps {\n  children?: React.ReactNode;\n  element?: React.ReactNode | null;\n}\n\nexport interface IndexRouteProps {\n  element?: React.ReactNode | null;\n  index: true;\n}\n\n/**\n * Declares an element that should be rendered at a certain URL path.\n *\n * @see https://reactrouter.com/docs/en/v6/api#route\n */\nexport function Route(\n  _props: PathRouteProps | LayoutRouteProps | IndexRouteProps\n): React.ReactElement | null {\n  invariant(\n    false,\n    `A <Route> is only ever to be used as the child of <Routes> element, ` +\n      `never rendered directly. Please wrap your <Route> in a <Routes>.`\n  );\n}\n\nexport interface RouterProps {\n  basename?: string;\n  children?: React.ReactNode;\n  location: Partial<Location> | string;\n  navigationType?: NavigationType;\n  navigator: Navigator;\n  static?: boolean;\n}\n\n/**\n * Provides location context for the rest of the app.\n *\n * Note: You usually won't render a <Router> directly. Instead, you'll render a\n * router that is more specific to your environment such as a <BrowserRouter>\n * in web browsers or a <StaticRouter> for server rendering.\n *\n * @see https://reactrouter.com/docs/en/v6/api#router\n */\nexport function Router({\n  basename: basenameProp = \"/\",\n  children = null,\n  location: locationProp,\n  navigationType = NavigationType.Pop,\n  navigator,\n  static: staticProp = false\n}: RouterProps): React.ReactElement | null {\n  invariant(\n    !useInRouterContext(),\n    `You cannot render a <Router> inside another <Router>.` +\n      ` You should never have more than one in your app.`\n  );\n\n  let basename = normalizePathname(basenameProp);\n  let navigationContext = React.useMemo(\n    () => ({ basename, navigator, static: staticProp }),\n    [basename, navigator, staticProp]\n  );\n\n  if (typeof locationProp === \"string\") {\n    locationProp = parsePath(locationProp);\n  }\n\n  let {\n    pathname = \"/\",\n    search = \"\",\n    hash = \"\",\n    state = null,\n    key = \"default\"\n  } = locationProp;\n\n  let location = React.useMemo(() => {\n    let trailingPathname = stripBasename(pathname, basename);\n\n    if (trailingPathname == null) {\n      return null;\n    }\n\n    return {\n      pathname: trailingPathname,\n      search,\n      hash,\n      state,\n      key\n    };\n  }, [basename, pathname, search, hash, state, key]);\n\n  warning(\n    location != null,\n    `<Router basename=\"${basename}\"> is not able to match the URL ` +\n      `\"${pathname}${search}${hash}\" because it does not start with the ` +\n      `basename, so the <Router> won't render anything.`\n  );\n\n  if (location == null) {\n    return null;\n  }\n\n  return (\n    <NavigationContext.Provider value={navigationContext}>\n      <LocationContext.Provider\n        children={children}\n        value={{ location, navigationType }}\n      />\n    </NavigationContext.Provider>\n  );\n}\n\nexport interface RoutesProps {\n  children?: React.ReactNode;\n  location?: Partial<Location> | string;\n}\n\n/**\n * A container for a nested tree of <Route> elements that renders the branch\n * that best matches the current location.\n *\n * @see https://reactrouter.com/docs/en/v6/api#routes\n */\nexport function Routes({\n  children,\n  location\n}: RoutesProps): React.ReactElement | null {\n  return useRoutes(createRoutesFromChildren(children), location);\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// HOOKS\n///////////////////////////////////////////////////////////////////////////////\n\n/**\n * Returns the full href for the given \"to\" value. This is useful for building\n * custom links that are also accessible and preserve right-click behavior.\n *\n * @see https://reactrouter.com/docs/en/v6/api#usehref\n */\nexport function useHref(to: To): string {\n  invariant(\n    useInRouterContext(),\n    // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    `useHref() may be used only in the context of a <Router> component.`\n  );\n\n  let { basename, navigator } = React.useContext(NavigationContext);\n  let { hash, pathname, search } = useResolvedPath(to);\n\n  let joinedPathname = pathname;\n  if (basename !== \"/\") {\n    let toPathname = getToPathname(to);\n    let endsWithSlash = toPathname != null && toPathname.endsWith(\"/\");\n    joinedPathname =\n      pathname === \"/\"\n        ? basename + (endsWithSlash ? \"/\" : \"\")\n        : joinPaths([basename, pathname]);\n  }\n\n  return navigator.createHref({ pathname: joinedPathname, search, hash });\n}\n\n/**\n * Returns true if this component is a descendant of a <Router>.\n *\n * @see https://reactrouter.com/docs/en/v6/api#useinroutercontext\n */\nexport function useInRouterContext(): boolean {\n  return React.useContext(LocationContext) != null;\n}\n\n/**\n * Returns the current location object, which represents the current URL in web\n * browsers.\n *\n * Note: If you're using this it may mean you're doing some of your own\n * \"routing\" in your app, and we'd like to know what your use case is. We may\n * be able to provide something higher-level to better suit your needs.\n *\n * @see https://reactrouter.com/docs/en/v6/api#uselocation\n */\nexport function useLocation(): Location {\n  invariant(\n    useInRouterContext(),\n    // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    `useLocation() may be used only in the context of a <Router> component.`\n  );\n\n  return React.useContext(LocationContext).location;\n}\n\ntype ParamParseFailed = { failed: true };\n\ntype ParamParseSegment<Segment extends string> =\n  // Check here if there exists a forward slash in the string.\n  Segment extends `${infer LeftSegment}/${infer RightSegment}`\n    ? // If there is a forward slash, then attempt to parse each side of the\n      // forward slash.\n      ParamParseSegment<LeftSegment> extends infer LeftResult\n      ? ParamParseSegment<RightSegment> extends infer RightResult\n        ? LeftResult extends string\n          ? // If the left side is successfully parsed as a param, then check if\n            // the right side can be successfully parsed as well. If both sides\n            // can be parsed, then the result is a union of the two sides\n            // (read: \"foo\" | \"bar\").\n            RightResult extends string\n            ? LeftResult | RightResult\n            : LeftResult\n          : // If the left side is not successfully parsed as a param, then check\n          // if only the right side can be successfully parse as a param. If it\n          // can, then the result is just right, else it's a failure.\n          RightResult extends string\n          ? RightResult\n          : ParamParseFailed\n        : ParamParseFailed\n      : // If the left side didn't parse into a param, then just check the right\n      // side.\n      ParamParseSegment<RightSegment> extends infer RightResult\n      ? RightResult extends string\n        ? RightResult\n        : ParamParseFailed\n      : ParamParseFailed\n    : // If there's no forward slash, then check if this segment starts with a\n    // colon. If it does, then this is a dynamic segment, so the result is\n    // just the remainder of the string. Otherwise, it's a failure.\n    Segment extends `:${infer Remaining}`\n    ? Remaining\n    : ParamParseFailed;\n\n// Attempt to parse the given string segment. If it fails, then just return the\n// plain string type as a default fallback. Otherwise return the union of the\n// parsed string literals that were referenced as dynamic segments in the route.\ntype ParamParseKey<Segment extends string> =\n  ParamParseSegment<Segment> extends string\n    ? ParamParseSegment<Segment>\n    : string;\n\n/**\n * Returns the current navigation action which describes how the router came to\n * the current location, either by a pop, push, or replace on the history stack.\n *\n * @see https://reactrouter.com/docs/en/v6/api#usenavigationtype\n */\nexport function useNavigationType(): NavigationType {\n  return React.useContext(LocationContext).navigationType;\n}\n\n/**\n * Returns true if the URL for the given \"to\" value matches the current URL.\n * This is useful for components that need to know \"active\" state, e.g.\n * <NavLink>.\n *\n * @see https://reactrouter.com/docs/en/v6/api#usematch\n */\nexport function useMatch<\n  ParamKey extends ParamParseKey<Path>,\n  Path extends string\n>(pattern: PathPattern<Path> | Path): PathMatch<ParamKey> | null {\n  invariant(\n    useInRouterContext(),\n    // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    `useMatch() may be used only in the context of a <Router> component.`\n  );\n\n  let { pathname } = useLocation();\n  return React.useMemo(\n    () => matchPath<ParamKey, Path>(pattern, pathname),\n    [pathname, pattern]\n  );\n}\n\n/**\n * The interface for the navigate() function returned from useNavigate().\n */\nexport interface NavigateFunction {\n  (to: To, options?: NavigateOptions): void;\n  (delta: number): void;\n}\n\nexport interface NavigateOptions {\n  replace?: boolean;\n  state?: any;\n}\n\n/**\n * Returns an imperative method for changing the location. Used by <Link>s, but\n * may also be used by other elements to change the location.\n *\n * @see https://reactrouter.com/docs/en/v6/api#usenavigate\n */\nexport function useNavigate(): NavigateFunction {\n  invariant(\n    useInRouterContext(),\n    // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    `useNavigate() may be used only in the context of a <Router> component.`\n  );\n\n  let { basename, navigator } = React.useContext(NavigationContext);\n  let { matches } = React.useContext(RouteContext);\n  let { pathname: locationPathname } = useLocation();\n\n  let routePathnamesJson = JSON.stringify(\n    matches.map(match => match.pathnameBase)\n  );\n\n  let activeRef = React.useRef(false);\n  React.useEffect(() => {\n    activeRef.current = true;\n  });\n\n  let navigate: NavigateFunction = React.useCallback(\n    (to: To | number, options: NavigateOptions = {}) => {\n      warning(\n        activeRef.current,\n        `You should call navigate() in a React.useEffect(), not when ` +\n          `your component is first rendered.`\n      );\n\n      if (!activeRef.current) return;\n\n      if (typeof to === \"number\") {\n        navigator.go(to);\n        return;\n      }\n\n      let path = resolveTo(\n        to,\n        JSON.parse(routePathnamesJson),\n        locationPathname\n      );\n\n      if (basename !== \"/\") {\n        path.pathname = joinPaths([basename, path.pathname]);\n      }\n\n      (!!options.replace ? navigator.replace : navigator.push)(\n        path,\n        options.state\n      );\n    },\n    [basename, navigator, routePathnamesJson, locationPathname]\n  );\n\n  return navigate;\n}\n\nconst OutletContext = React.createContext<unknown>(null);\n\n/**\n * Returns the context (if provided) for the child route at this level of the route\n * hierarchy.\n * @see https://reactrouter.com/docs/en/v6/api#useoutletcontext\n */\nexport function useOutletContext<Context = unknown>(): Context {\n  return React.useContext(OutletContext) as Context;\n}\n\n/**\n * Returns the element for the child route at this level of the route\n * hierarchy. Used internally by <Outlet> to render child routes.\n *\n * @see https://reactrouter.com/docs/en/v6/api#useoutlet\n */\nexport function useOutlet(context?: unknown): React.ReactElement | null {\n  let outlet = React.useContext(RouteContext).outlet;\n  if (outlet) {\n    return (\n      <OutletContext.Provider value={context}>{outlet}</OutletContext.Provider>\n    );\n  }\n  return outlet;\n}\n\n/**\n * Returns an object of key/value pairs of the dynamic params from the current\n * URL that were matched by the route path.\n *\n * @see https://reactrouter.com/docs/en/v6/api#useparams\n */\nexport function useParams<\n  ParamsOrKey extends string | Record<string, string | undefined> = string\n>(): Readonly<\n  [ParamsOrKey] extends [string] ? Params<ParamsOrKey> : Partial<ParamsOrKey>\n> {\n  let { matches } = React.useContext(RouteContext);\n  let routeMatch = matches[matches.length - 1];\n  return routeMatch ? (routeMatch.params as any) : {};\n}\n\n/**\n * Resolves the pathname of the given `to` value against the current location.\n *\n * @see https://reactrouter.com/docs/en/v6/api#useresolvedpath\n */\nexport function useResolvedPath(to: To): Path {\n  let { matches } = React.useContext(RouteContext);\n  let { pathname: locationPathname } = useLocation();\n\n  let routePathnamesJson = JSON.stringify(\n    matches.map(match => match.pathnameBase)\n  );\n\n  return React.useMemo(\n    () => resolveTo(to, JSON.parse(routePathnamesJson), locationPathname),\n    [to, routePathnamesJson, locationPathname]\n  );\n}\n\n/**\n * Returns the element of the route that matched the current location, prepared\n * with the correct context to render the remainder of the route tree. Route\n * elements in the tree must render an <Outlet> to render their child route's\n * element.\n *\n * @see https://reactrouter.com/docs/en/v6/api#useroutes\n */\nexport function useRoutes(\n  routes: RouteObject[],\n  locationArg?: Partial<Location> | string\n): React.ReactElement | null {\n  invariant(\n    useInRouterContext(),\n    // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    `useRoutes() may be used only in the context of a <Router> component.`\n  );\n\n  let { matches: parentMatches } = React.useContext(RouteContext);\n  let routeMatch = parentMatches[parentMatches.length - 1];\n  let parentParams = routeMatch ? routeMatch.params : {};\n  let parentPathname = routeMatch ? routeMatch.pathname : \"/\";\n  let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : \"/\";\n  let parentRoute = routeMatch && routeMatch.route;\n\n  if (__DEV__) {\n    // You won't get a warning about 2 different <Routes> under a <Route>\n    // without a trailing *, but this is a best-effort warning anyway since we\n    // cannot even give the warning unless they land at the parent route.\n    //\n    // Example:\n    //\n    // <Routes>\n    //   {/* This route path MUST end with /* because otherwise\n    //       it will never match /blog/post/123 */}\n    //   <Route path=\"blog\" element={<Blog />} />\n    //   <Route path=\"blog/feed\" element={<BlogFeed />} />\n    // </Routes>\n    //\n    // function Blog() {\n    //   return (\n    //     <Routes>\n    //       <Route path=\"post/:id\" element={<Post />} />\n    //     </Routes>\n    //   );\n    // }\n    let parentPath = (parentRoute && parentRoute.path) || \"\";\n    warningOnce(\n      parentPathname,\n      !parentRoute || parentPath.endsWith(\"*\"),\n      `You rendered descendant <Routes> (or called \\`useRoutes()\\`) at ` +\n        `\"${parentPathname}\" (under <Route path=\"${parentPath}\">) but the ` +\n        `parent route path has no trailing \"*\". This means if you navigate ` +\n        `deeper, the parent won't match anymore and therefore the child ` +\n        `routes will never render.\\n\\n` +\n        `Please change the parent <Route path=\"${parentPath}\"> to <Route ` +\n        `path=\"${parentPath === \"/\" ? \"*\" : `${parentPath}/*`}\">.`\n    );\n  }\n\n  let locationFromContext = useLocation();\n\n  let location;\n  if (locationArg) {\n    let parsedLocationArg =\n      typeof locationArg === \"string\" ? parsePath(locationArg) : locationArg;\n\n    invariant(\n      parentPathnameBase === \"/\" ||\n        parsedLocationArg.pathname?.startsWith(parentPathnameBase),\n      `When overriding the location using \\`<Routes location>\\` or \\`useRoutes(routes, location)\\`, ` +\n        `the location pathname must begin with the portion of the URL pathname that was ` +\n        `matched by all parent routes. The current pathname base is \"${parentPathnameBase}\" ` +\n        `but pathname \"${parsedLocationArg.pathname}\" was given in the \\`location\\` prop.`\n    );\n\n    location = parsedLocationArg;\n  } else {\n    location = locationFromContext;\n  }\n\n  let pathname = location.pathname || \"/\";\n  let remainingPathname =\n    parentPathnameBase === \"/\"\n      ? pathname\n      : pathname.slice(parentPathnameBase.length) || \"/\";\n  let matches = matchRoutes(routes, { pathname: remainingPathname });\n\n  if (__DEV__) {\n    warning(\n      parentRoute || matches != null,\n      `No routes matched location \"${location.pathname}${location.search}${location.hash}\" `\n    );\n\n    warning(\n      matches == null ||\n        matches[matches.length - 1].route.element !== undefined,\n      `Matched leaf route at location \"${location.pathname}${location.search}${location.hash}\" does not have an element. ` +\n        `This means it will render an <Outlet /> with a null value by default resulting in an \"empty\" page.`\n    );\n  }\n\n  return _renderMatches(\n    matches &&\n      matches.map(match =>\n        Object.assign({}, match, {\n          params: Object.assign({}, parentParams, match.params),\n          pathname: joinPaths([parentPathnameBase, match.pathname]),\n          pathnameBase:\n            match.pathnameBase === \"/\"\n              ? parentPathnameBase\n              : joinPaths([parentPathnameBase, match.pathnameBase])\n        })\n      ),\n    parentMatches\n  );\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// UTILS\n///////////////////////////////////////////////////////////////////////////////\n\n/**\n * Creates a route config from a React \"children\" object, which is usually\n * either a `<Route>` element or an array of them. Used internally by\n * `<Routes>` to create a route config from its children.\n *\n * @see https://reactrouter.com/docs/en/v6/api#createroutesfromchildren\n */\nexport function createRoutesFromChildren(\n  children: React.ReactNode\n): RouteObject[] {\n  let routes: RouteObject[] = [];\n\n  React.Children.forEach(children, element => {\n    if (!React.isValidElement(element)) {\n      // Ignore non-elements. This allows people to more easily inline\n      // conditionals in their route config.\n      return;\n    }\n\n    if (element.type === React.Fragment) {\n      // Transparently support React.Fragment and its children.\n      routes.push.apply(\n        routes,\n        createRoutesFromChildren(element.props.children)\n      );\n      return;\n    }\n\n    invariant(\n      element.type === Route,\n      `[${\n        typeof element.type === \"string\" ? element.type : element.type.name\n      }] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>`\n    );\n\n    let route: RouteObject = {\n      caseSensitive: element.props.caseSensitive,\n      element: element.props.element,\n      index: element.props.index,\n      path: element.props.path\n    };\n\n    if (element.props.children) {\n      route.children = createRoutesFromChildren(element.props.children);\n    }\n\n    routes.push(route);\n  });\n\n  return routes;\n}\n\n/**\n * The parameters that were parsed from the URL path.\n */\nexport type Params<Key extends string = string> = {\n  readonly [key in Key]: string | undefined;\n};\n\n/**\n * A route object represents a logical route, with (optionally) its child\n * routes organized in a tree-like structure.\n */\nexport interface RouteObject {\n  caseSensitive?: boolean;\n  children?: RouteObject[];\n  element?: React.ReactNode;\n  index?: boolean;\n  path?: string;\n}\n\n/**\n * Returns a path with params interpolated.\n *\n * @see https://reactrouter.com/docs/en/v6/api#generatepath\n */\nexport function generatePath(path: string, params: Params = {}): string {\n  return path\n    .replace(/:(\\w+)/g, (_, key) => {\n      invariant(params[key] != null, `Missing \":${key}\" param`);\n      return params[key]!;\n    })\n    .replace(/\\/*\\*$/, _ =>\n      params[\"*\"] == null ? \"\" : params[\"*\"].replace(/^\\/*/, \"/\")\n    );\n}\n\n/**\n * A RouteMatch contains info about how a route matched a URL.\n */\nexport interface RouteMatch<ParamKey extends string = string> {\n  /**\n   * The names and values of dynamic parameters in the URL.\n   */\n  params: Params<ParamKey>;\n  /**\n   * The portion of the URL pathname that was matched.\n   */\n  pathname: string;\n  /**\n   * The portion of the URL pathname that was matched before child routes.\n   */\n  pathnameBase: string;\n  /**\n   * The route object that was used to match.\n   */\n  route: RouteObject;\n}\n\n/**\n * Matches the given routes to a location and returns the match data.\n *\n * @see https://reactrouter.com/docs/en/v6/api#matchroutes\n */\nexport function matchRoutes(\n  routes: RouteObject[],\n  locationArg: Partial<Location> | string,\n  basename = \"/\"\n): RouteMatch[] | null {\n  let location =\n    typeof locationArg === \"string\" ? parsePath(locationArg) : locationArg;\n\n  let pathname = stripBasename(location.pathname || \"/\", basename);\n\n  if (pathname == null) {\n    return null;\n  }\n\n  let branches = flattenRoutes(routes);\n  rankRouteBranches(branches);\n\n  let matches = null;\n  for (let i = 0; matches == null && i < branches.length; ++i) {\n    matches = matchRouteBranch(branches[i], pathname);\n  }\n\n  return matches;\n}\n\ninterface RouteMeta {\n  relativePath: string;\n  caseSensitive: boolean;\n  childrenIndex: number;\n  route: RouteObject;\n}\n\ninterface RouteBranch {\n  path: string;\n  score: number;\n  routesMeta: RouteMeta[];\n}\n\nfunction flattenRoutes(\n  routes: RouteObject[],\n  branches: RouteBranch[] = [],\n  parentsMeta: RouteMeta[] = [],\n  parentPath = \"\"\n): RouteBranch[] {\n  routes.forEach((route, index) => {\n    let meta: RouteMeta = {\n      relativePath: route.path || \"\",\n      caseSensitive: route.caseSensitive === true,\n      childrenIndex: index,\n      route\n    };\n\n    if (meta.relativePath.startsWith(\"/\")) {\n      invariant(\n        meta.relativePath.startsWith(parentPath),\n        `Absolute route path \"${meta.relativePath}\" nested under path ` +\n          `\"${parentPath}\" is not valid. An absolute child route path ` +\n          `must start with the combined path of all its parent routes.`\n      );\n\n      meta.relativePath = meta.relativePath.slice(parentPath.length);\n    }\n\n    let path = joinPaths([parentPath, meta.relativePath]);\n    let routesMeta = parentsMeta.concat(meta);\n\n    // Add the children before adding this route to the array so we traverse the\n    // route tree depth-first and child routes appear before their parents in\n    // the \"flattened\" version.\n    if (route.children && route.children.length > 0) {\n      invariant(\n        route.index !== true,\n        `Index routes must not have child routes. Please remove ` +\n          `all child routes from route path \"${path}\".`\n      );\n\n      flattenRoutes(route.children, branches, routesMeta, path);\n    }\n\n    // Routes without a path shouldn't ever match by themselves unless they are\n    // index routes, so don't add them to the list of possible branches.\n    if (route.path == null && !route.index) {\n      return;\n    }\n\n    branches.push({ path, score: computeScore(path, route.index), routesMeta });\n  });\n\n  return branches;\n}\n\nfunction rankRouteBranches(branches: RouteBranch[]): void {\n  branches.sort((a, b) =>\n    a.score !== b.score\n      ? b.score - a.score // Higher score first\n      : compareIndexes(\n          a.routesMeta.map(meta => meta.childrenIndex),\n          b.routesMeta.map(meta => meta.childrenIndex)\n        )\n  );\n}\n\nconst paramRe = /^:\\w+$/;\nconst dynamicSegmentValue = 3;\nconst indexRouteValue = 2;\nconst emptySegmentValue = 1;\nconst staticSegmentValue = 10;\nconst splatPenalty = -2;\nconst isSplat = (s: string) => s === \"*\";\n\nfunction computeScore(path: string, index: boolean | undefined): number {\n  let segments = path.split(\"/\");\n  let initialScore = segments.length;\n  if (segments.some(isSplat)) {\n    initialScore += splatPenalty;\n  }\n\n  if (index) {\n    initialScore += indexRouteValue;\n  }\n\n  return segments\n    .filter(s => !isSplat(s))\n    .reduce(\n      (score, segment) =>\n        score +\n        (paramRe.test(segment)\n          ? dynamicSegmentValue\n          : segment === \"\"\n          ? emptySegmentValue\n          : staticSegmentValue),\n      initialScore\n    );\n}\n\nfunction compareIndexes(a: number[], b: number[]): number {\n  let siblings =\n    a.length === b.length && a.slice(0, -1).every((n, i) => n === b[i]);\n\n  return siblings\n    ? // If two routes are siblings, we should try to match the earlier sibling\n      // first. This allows people to have fine-grained control over the matching\n      // behavior by simply putting routes with identical paths in the order they\n      // want them tried.\n      a[a.length - 1] - b[b.length - 1]\n    : // Otherwise, it doesn't really make sense to rank non-siblings by index,\n      // so they sort equally.\n      0;\n}\n\nfunction matchRouteBranch<ParamKey extends string = string>(\n  branch: RouteBranch,\n  pathname: string\n): RouteMatch<ParamKey>[] | null {\n  let { routesMeta } = branch;\n\n  let matchedParams = {};\n  let matchedPathname = \"/\";\n  let matches: RouteMatch[] = [];\n  for (let i = 0; i < routesMeta.length; ++i) {\n    let meta = routesMeta[i];\n    let end = i === routesMeta.length - 1;\n    let remainingPathname =\n      matchedPathname === \"/\"\n        ? pathname\n        : pathname.slice(matchedPathname.length) || \"/\";\n    let match = matchPath(\n      { path: meta.relativePath, caseSensitive: meta.caseSensitive, end },\n      remainingPathname\n    );\n\n    if (!match) return null;\n\n    Object.assign(matchedParams, match.params);\n\n    let route = meta.route;\n\n    matches.push({\n      params: matchedParams,\n      pathname: joinPaths([matchedPathname, match.pathname]),\n      pathnameBase: joinPaths([matchedPathname, match.pathnameBase]),\n      route\n    });\n\n    if (match.pathnameBase !== \"/\") {\n      matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);\n    }\n  }\n\n  return matches;\n}\n\n/**\n * Renders the result of `matchRoutes()` into a React element.\n */\nexport function renderMatches(\n  matches: RouteMatch[] | null\n): React.ReactElement | null {\n  return _renderMatches(matches);\n}\n\nfunction _renderMatches(\n  matches: RouteMatch[] | null,\n  parentMatches: RouteMatch[] = []\n): React.ReactElement | null {\n  if (matches == null) return null;\n\n  return matches.reduceRight((outlet, match, index) => {\n    return (\n      <RouteContext.Provider\n        children={\n          match.route.element !== undefined ? match.route.element : <Outlet />\n        }\n        value={{\n          outlet,\n          matches: parentMatches.concat(matches.slice(0, index + 1))\n        }}\n      />\n    );\n  }, null as React.ReactElement | null);\n}\n\n/**\n * A PathPattern is used to match on some portion of a URL pathname.\n */\nexport interface PathPattern<Path extends string = string> {\n  /**\n   * A string to match against a URL pathname. May contain `:id`-style segments\n   * to indicate placeholders for dynamic parameters. May also end with `/*` to\n   * indicate matching the rest of the URL pathname.\n   */\n  path: Path;\n  /**\n   * Should be `true` if the static portions of the `path` should be matched in\n   * the same case.\n   */\n  caseSensitive?: boolean;\n  /**\n   * Should be `true` if this pattern should match the entire URL pathname.\n   */\n  end?: boolean;\n}\n\n/**\n * A PathMatch contains info about how a PathPattern matched on a URL pathname.\n */\nexport interface PathMatch<ParamKey extends string = string> {\n  /**\n   * The names and values of dynamic parameters in the URL.\n   */\n  params: Params<ParamKey>;\n  /**\n   * The portion of the URL pathname that was matched.\n   */\n  pathname: string;\n  /**\n   * The portion of the URL pathname that was matched before child routes.\n   */\n  pathnameBase: string;\n  /**\n   * The pattern that was used to match.\n   */\n  pattern: PathPattern;\n}\n\ntype Mutable<T> = {\n  -readonly [P in keyof T]: T[P];\n};\n\n/**\n * Performs pattern matching on a URL pathname and returns information about\n * the match.\n *\n * @see https://reactrouter.com/docs/en/v6/api#matchpath\n */\nexport function matchPath<\n  ParamKey extends ParamParseKey<Path>,\n  Path extends string\n>(\n  pattern: PathPattern<Path> | Path,\n  pathname: string\n): PathMatch<ParamKey> | null {\n  if (typeof pattern === \"string\") {\n    pattern = { path: pattern, caseSensitive: false, end: true };\n  }\n\n  let [matcher, paramNames] = compilePath(\n    pattern.path,\n    pattern.caseSensitive,\n    pattern.end\n  );\n\n  let match = pathname.match(matcher);\n  if (!match) return null;\n\n  let matchedPathname = match[0];\n  let pathnameBase = matchedPathname.replace(/(.)\\/+$/, \"$1\");\n  let captureGroups = match.slice(1);\n  let params: Params = paramNames.reduce<Mutable<Params>>(\n    (memo, paramName, index) => {\n      // We need to compute the pathnameBase here using the raw splat value\n      // instead of using params[\"*\"] later because it will be decoded then\n      if (paramName === \"*\") {\n        let splatValue = captureGroups[index] || \"\";\n        pathnameBase = matchedPathname\n          .slice(0, matchedPathname.length - splatValue.length)\n          .replace(/(.)\\/+$/, \"$1\");\n      }\n\n      memo[paramName] = safelyDecodeURIComponent(\n        captureGroups[index] || \"\",\n        paramName\n      );\n      return memo;\n    },\n    {}\n  );\n\n  return {\n    params,\n    pathname: matchedPathname,\n    pathnameBase,\n    pattern\n  };\n}\n\nfunction compilePath(\n  path: string,\n  caseSensitive = false,\n  end = true\n): [RegExp, string[]] {\n  warning(\n    path === \"*\" || !path.endsWith(\"*\") || path.endsWith(\"/*\"),\n    `Route path \"${path}\" will be treated as if it were ` +\n      `\"${path.replace(/\\*$/, \"/*\")}\" because the \\`*\\` character must ` +\n      `always follow a \\`/\\` in the pattern. To get rid of this warning, ` +\n      `please change the route path to \"${path.replace(/\\*$/, \"/*\")}\".`\n  );\n\n  let paramNames: string[] = [];\n  let regexpSource =\n    \"^\" +\n    path\n      .replace(/\\/*\\*?$/, \"\") // Ignore trailing / and /*, we'll handle it below\n      .replace(/^\\/*/, \"/\") // Make sure it has a leading /\n      .replace(/[\\\\.*+^$?{}|()[\\]]/g, \"\\\\$&\") // Escape special regex chars\n      .replace(/:(\\w+)/g, (_: string, paramName: string) => {\n        paramNames.push(paramName);\n        return \"([^\\\\/]+)\";\n      });\n\n  if (path.endsWith(\"*\")) {\n    paramNames.push(\"*\");\n    regexpSource +=\n      path === \"*\" || path === \"/*\"\n        ? \"(.*)$\" // Already matched the initial /, just match the rest\n        : \"(?:\\\\/(.+)|\\\\/*)$\"; // Don't include the / in params[\"*\"]\n  } else {\n    regexpSource += end\n      ? \"\\\\/*$\" // When matching to the end, ignore trailing slashes\n      : // Otherwise, match a word boundary or a proceeding /. The word boundary restricts\n        // parent routes to matching only their own words and nothing more, e.g. parent\n        // route \"/home\" should not match \"/home2\".\n        \"(?:\\\\b|\\\\/|$)\";\n  }\n\n  let matcher = new RegExp(regexpSource, caseSensitive ? undefined : \"i\");\n\n  return [matcher, paramNames];\n}\n\nfunction safelyDecodeURIComponent(value: string, paramName: string) {\n  try {\n    return decodeURIComponent(value);\n  } catch (error) {\n    warning(\n      false,\n      `The value for the URL param \"${paramName}\" will not be decoded because` +\n        ` the string \"${value}\" is a malformed URL segment. This is probably` +\n        ` due to a bad percent encoding (${error}).`\n    );\n\n    return value;\n  }\n}\n\n/**\n * Returns a resolved path object relative to the given pathname.\n *\n * @see https://reactrouter.com/docs/en/v6/api#resolvepath\n */\nexport function resolvePath(to: To, fromPathname = \"/\"): Path {\n  let {\n    pathname: toPathname,\n    search = \"\",\n    hash = \"\"\n  } = typeof to === \"string\" ? parsePath(to) : to;\n\n  let pathname = toPathname\n    ? toPathname.startsWith(\"/\")\n      ? toPathname\n      : resolvePathname(toPathname, fromPathname)\n    : fromPathname;\n\n  return {\n    pathname,\n    search: normalizeSearch(search),\n    hash: normalizeHash(hash)\n  };\n}\n\nfunction resolvePathname(relativePath: string, fromPathname: string): string {\n  let segments = fromPathname.replace(/\\/+$/, \"\").split(\"/\");\n  let relativeSegments = relativePath.split(\"/\");\n\n  relativeSegments.forEach(segment => {\n    if (segment === \"..\") {\n      // Keep the root \"\" segment so the pathname starts at /\n      if (segments.length > 1) segments.pop();\n    } else if (segment !== \".\") {\n      segments.push(segment);\n    }\n  });\n\n  return segments.length > 1 ? segments.join(\"/\") : \"/\";\n}\n\nfunction resolveTo(\n  toArg: To,\n  routePathnames: string[],\n  locationPathname: string\n): Path {\n  let to = typeof toArg === \"string\" ? parsePath(toArg) : toArg;\n  let toPathname = toArg === \"\" || to.pathname === \"\" ? \"/\" : to.pathname;\n\n  // If a pathname is explicitly provided in `to`, it should be relative to the\n  // route context. This is explained in `Note on `<Link to>` values` in our\n  // migration guide from v5 as a means of disambiguation between `to` values\n  // that begin with `/` and those that do not. However, this is problematic for\n  // `to` values that do not provide a pathname. `to` can simply be a search or\n  // hash string, in which case we should assume that the navigation is relative\n  // to the current location's pathname and *not* the route pathname.\n  let from: string;\n  if (toPathname == null) {\n    from = locationPathname;\n  } else {\n    let routePathnameIndex = routePathnames.length - 1;\n\n    if (toPathname.startsWith(\"..\")) {\n      let toSegments = toPathname.split(\"/\");\n\n      // Each leading .. segment means \"go up one route\" instead of \"go up one\n      // URL segment\".  This is a key difference from how <a href> works and a\n      // major reason we call this a \"to\" value instead of a \"href\".\n      while (toSegments[0] === \"..\") {\n        toSegments.shift();\n        routePathnameIndex -= 1;\n      }\n\n      to.pathname = toSegments.join(\"/\");\n    }\n\n    // If there are more \"..\" segments than parent routes, resolve relative to\n    // the root / URL.\n    from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : \"/\";\n  }\n\n  let path = resolvePath(to, from);\n\n  // Ensure the pathname has a trailing slash if the original to value had one.\n  if (\n    toPathname &&\n    toPathname !== \"/\" &&\n    toPathname.endsWith(\"/\") &&\n    !path.pathname.endsWith(\"/\")\n  ) {\n    path.pathname += \"/\";\n  }\n\n  return path;\n}\n\nfunction getToPathname(to: To): string | undefined {\n  // Empty strings should be treated the same as / paths\n  return to === \"\" || (to as Path).pathname === \"\"\n    ? \"/\"\n    : typeof to === \"string\"\n    ? parsePath(to).pathname\n    : to.pathname;\n}\n\nfunction stripBasename(pathname: string, basename: string): string | null {\n  if (basename === \"/\") return pathname;\n\n  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {\n    return null;\n  }\n\n  let nextChar = pathname.charAt(basename.length);\n  if (nextChar && nextChar !== \"/\") {\n    // pathname does not start with basename/\n    return null;\n  }\n\n  return pathname.slice(basename.length) || \"/\";\n}\n\nconst joinPaths = (paths: string[]): string =>\n  paths.join(\"/\").replace(/\\/\\/+/g, \"/\");\n\nconst normalizePathname = (pathname: string): string =>\n  pathname.replace(/\\/+$/, \"\").replace(/^\\/*/, \"/\");\n\nconst normalizeSearch = (search: string): string =>\n  !search || search === \"?\"\n    ? \"\"\n    : search.startsWith(\"?\")\n    ? search\n    : \"?\" + search;\n\nconst normalizeHash = (hash: string): string =>\n  !hash || hash === \"#\" ? \"\" : hash.startsWith(\"#\") ? hash : \"#\" + hash;\n\n///////////////////////////////////////////////////////////////////////////////\n// DANGER! PLEASE READ ME!\n// We provide these exports as an escape hatch in the event that you need any\n// routing data that we don't provide an explicit API for. With that said, we\n// want to cover your use case if we can, so if you feel the need to use these\n// we want to hear from you. Let us know what you're building and we'll do our\n// best to make sure we can support you!\n//\n// We consider these exports an implementation detail and do not guarantee\n// against any breaking changes, regardless of the semver release. Use with\n// extreme caution and only if you understand the consequences. Godspeed.\n///////////////////////////////////////////////////////////////////////////////\n\n/** @internal */\nexport {\n  NavigationContext as UNSAFE_NavigationContext,\n  LocationContext as UNSAFE_LocationContext,\n  RouteContext as UNSAFE_RouteContext\n};\n"]},"metadata":{},"sourceType":"module"}